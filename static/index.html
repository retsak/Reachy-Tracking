<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reachy Control</title>
    <link rel="stylesheet" href="/static/style.css?v=2">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ¤–</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div class="dashboard">
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         HEADER
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <header class="header">
            <h1>ğŸ¤– Reachy Control</h1>
            <div class="header-controls">
                <div class="theme-selector">
                    <label for="theme-select">ğŸ¨</label>
                    <select id="theme-select">
                        <option value="dark">Dark</option>
                        <option value="light">Light</option>
                        <option value="ocean">Ocean</option>
                        <option value="forest">Forest</option>
                        <option value="hacker">Hacker</option>
                        <option value="halloween">Halloween</option>
                        <option value="christmas">Christmas</option>
                        <option value="newyear">New Year</option>
                        <option value="sunset">Sunset</option>
                        <option value="cyberpunk">Cyberpunk</option>
                        <option value="midnight">Midnight</option>
                        <option value="lavender">Lavender</option>
                        <option value="retro">Retro</option>
                        <option value="arctic">Arctic</option>
                        <option value="volcano">Volcano</option>
                        <option value="synthwave">Synthwave</option>
                        <option value="coffee">Coffee</option>
                        <option value="cherry">Cherry</option>
                        <option value="unicorn">ğŸ¦„ Unicorn Barf</option>
                        <option value="nyan">ğŸ± Nyan Cat</option>
                    </select>
                </div>
                <button class="header-btn" id="settings-btn" title="Settings">âš™ï¸</button>
                <div class="header-status">
                    <span><span class="status-dot"></span><span id="status-text">Ready</span></span>
                    <span>ğŸ”Œ Connected</span>
                </div>
            </div>
        </header>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         LEFT SIDEBAR - Quick Actions
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="panel sidebar-left">
            <div class="panel-title">Quick Actions</div>
            <div class="panel-content">
                <div class="action-list">
                    <button class="action-btn" id="wiggle-btn">
                        <span class="icon">ğŸ­</span> Wiggle Mode
                    </button>
                    <button class="action-btn" id="pause-btn">
                        <span class="icon">â¸ï¸</span> Pause Tracking
                    </button>
                    <button class="action-btn" id="reset-btn">
                        <span class="icon">ğŸ”„</span> Reset Position
                    </button>
                    <button class="action-btn" id="voice-btn">
                        <span class="icon">ğŸ¤</span> Voice Assistant
                    </button>
                </div>

                <div style="margin-top:24px;">
                    <div class="panel-title" style="padding:0; border:none; margin-bottom:12px;">Motor Mode</div>
                    <div class="action-list">
                        <button class="action-btn" onclick="setMotorMode('stiff')">
                            <span class="icon">ğŸ’ª</span> Stiff
                        </button>
                        <button class="action-btn" onclick="setMotorMode('soft')">
                            <span class="icon">â˜ï¸</span> Soft
                        </button>
                        <button class="action-btn" onclick="setMotorMode('limp')">
                            <span class="icon">ğŸ’¤</span> Limp
                        </button>
                    </div>
                </div>

                <div style="margin-top:auto; padding-top:24px; display:flex; flex-direction:column; gap:8px;">
                    <button class="action-btn" id="restart-btn" style="background:#FFA500; color:#000;">
                        <span class="icon">ğŸ”„</span> Restart
                    </button>
                    <button class="action-btn danger" id="power-btn">
                        <span class="icon">â›”</span> Shutdown
                    </button>
                </div>
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         CENTER - Video + Manual Controls
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="main-center">
            <!-- Video Panel - COMPACT -->
            <div class="panel video-panel">
                <div class="video-frame">
                    <img src="/video_feed" alt="Video Feed" id="video-feed">
                    <div class="video-label">LIVE FEED</div>
                </div>
            </div>

            <!-- Manual Controls -->
            <div class="panel controls-panel">
                <div class="panel-title">Manual Control</div>
                <div class="panel-content">
                    <div id="manual-overlay" style="opacity:0.4; pointer-events:none;">
                        <div class="control-grid">
                        <div class="control-group">
                            <h4>Antennas</h4>
                            <div class="slider-row">
                                <div class="slider-label"><span>Left</span><span class="slider-val"
                                        id="val-ant-l">0Â°</span></div>
                                <input type="range" id="ant-l" min="-180" max="180" value="0">
                            </div>
                            <div class="slider-row">
                                <div class="slider-label"><span>Right</span><span class="slider-val"
                                        id="val-ant-r">0Â°</span></div>
                                <input type="range" id="ant-r" min="-180" max="180" value="0">
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Head</h4>
                            <div class="slider-row">
                                <div class="slider-label"><span>Yaw</span><span class="slider-val"
                                        id="val-head-y">0Â°</span></div>
                                <input type="range" id="head-y" min="-90" max="90" value="0">
                            </div>
                            <div class="slider-row">
                                <div class="slider-label"><span>Pitch</span><span class="slider-val"
                                        id="val-head-p">0Â°</span></div>
                                <input type="range" id="head-p" min="-45" max="45" value="0">
                            </div>
                            <div class="slider-row">
                                <div class="slider-label"><span>Roll</span><span class="slider-val"
                                        id="val-head-r">0Â°</span></div>
                                <input type="range" id="head-r" min="-45" max="45" value="0">
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Body</h4>
                            <div class="slider-row">
                                <div class="slider-label"><span>Body Yaw</span><span class="slider-val"
                                        id="val-body-y">0Â°</span></div>
                                <input type="range" id="body-y" min="-150" max="150" value="0">
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Emotions</h4>
                            <div class="emotion-actions">
                                <button onclick="triggerEmotion('happy')" class="action-btn" title="Happy">ğŸ˜„</button>
                                <button onclick="triggerEmotion('excited')" class="action-btn" title="Excited">ğŸ¤©</button>
                                <button onclick="triggerEmotion('sad')" class="action-btn" title="Sad">ğŸ˜¢</button>
                                <button onclick="triggerEmotion('angry')" class="action-btn" title="Angry">ğŸ˜ </button>
                                <button onclick="triggerEmotion('confused')" class="action-btn" title="Confused">ğŸ˜•</button>
                                <button onclick="triggerEmotion('surprised')" class="action-btn" title="Surprised">ğŸ˜²</button>
                                <button onclick="triggerEmotion('love')" class="action-btn" title="Love">ğŸ˜</button>
                                <button onclick="triggerEmotion('thinking')" class="action-btn" title="Thinking">ğŸ¤”</button>
                                <button onclick="triggerEmotion('cool')" class="action-btn" title="Cool">ğŸ˜</button>
                                <button onclick="triggerEmotion('yay')" class="action-btn" title="Yay">ğŸ‰</button>
                                <button onclick="triggerEmotion('nervous')" class="action-btn" title="Nervous">ğŸ˜°</button>
                                <button onclick="triggerEmotion('sick')" class="action-btn" title="Sick">ğŸ¤’</button>
                                <button onclick="triggerEmotion('sleeping')" class="action-btn" title="Sleeping">ğŸ˜´</button>
                                <button onclick="triggerEmotion('party')" class="action-btn" title="Party">ğŸ¥³</button>
                                <button onclick="triggerEmotion('clap')" class="action-btn" title="Applause">ğŸ‘</button>
                                <button onclick="triggerEmotion('thumbsup')" class="action-btn" title="Thumbs Up">ğŸ‘</button>
                                <button onclick="triggerEmotion('thumbsdown')" class="action-btn" title="Thumbs Down">ğŸ‘</button>
                                <button onclick="triggerEmotion('wave')" class="action-btn" title="Wave">ğŸ‘‹</button>
                                <button onclick="triggerEmotion('dance')" class="action-btn" title="Dance">ğŸ’ƒ</button>
                                <button onclick="triggerEmotion('celebration')" class="action-btn" title="Celebration">ğŸŠ</button>
                                <button onclick="triggerEmotion('curious')" class="action-btn" title="Curious">ğŸ¤¨</button>
                                <button onclick="triggerEmotion('grimace')" class="action-btn" title="Grimace">ğŸ˜¬</button>
                                <button onclick="triggerEmotion('scared')" class="action-btn" title="Scared">ğŸ˜¨</button>
                                <button onclick="triggerEmotion('tired')" class="action-btn" title="Tired">ğŸ˜«</button>
                                <button onclick="triggerEmotion('peaceful')" class="action-btn" title="Peaceful">ğŸ˜Œ</button>
                            </div>
                        </div>
                        </div>
                    </div>

                    <!-- Voice controls should stay usable even when manual control is off -->
                    <div class="voice-controls">
                        <div class="control-group" style="margin-bottom:16px;">
                            <button id="push-to-talk-btn" style="width:100%; padding:24px; font-size:18px; font-weight:bold; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:#fff; border:none; border-radius:12px; cursor:pointer; box-shadow:0 4px 12px rgba(102,126,234,0.3); transition:all 0.2s; text-shadow:0 1px 2px rgba(0,0,0,0.2);">
                                ğŸ¤ Hold to Talk
                            </button>
                            <div id="ptt-status" style="text-align:center; margin-top:8px; font-size:13px; color:var(--text-muted); min-height:20px;"></div>
                        </div>
                        <div class="control-group" style="margin-bottom:16px;">
                            <button id="stop-speech-btn" style="width:100%; padding:16px; font-size:16px; font-weight:bold; background:linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color:#fff; border:none; border-radius:12px; cursor:pointer; box-shadow:0 4px 12px rgba(239,68,68,0.3); transition:all 0.2s;">
                                ğŸ›‘ Stop Speech
                            </button>
                        </div>
                        <div class="control-group">
                            <h4>Voice Volume</h4>
                            <div class="slider-row">
                                <div class="slider-label"><span>Level</span><span class="slider-val" id="volume-val">50%</span></div>
                                <input type="range" id="volume-slider" min="0" max="100" value="50">
                            </div>
                        </div>
                        <div class="control-group" style="margin-top:12px;">
                            <h4 style="display:flex; align-items:center; justify-content:space-between;">
                                Microphone Level
                                <small id="mic-level-db-main" style="color:var(--text-muted); font-size:11px; font-weight:normal;">-âˆ dB</small>
                            </h4>
                            <div style="position:relative; height:12px; background:var(--bg-elevated); border-radius:6px; overflow:hidden;">
                                <div id="mic-level-bar-main" style="position:absolute; left:0; top:0; height:100%; width:0%; background:linear-gradient(90deg, #4ade80, #f97316, #ef4444); transition:width 0.1s ease-out;"></div>
                            </div>
                            <button id="test-mic-level-btn" style="margin-top:6px; padding:6px 12px; font-size:11px; background:var(--accent); color:#000; border:none; border-radius:3px; cursor:pointer;">Test Mic Level</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         RIGHT SIDEBAR - Chat + Data
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="sidebar-right">
            <!-- Chat -->
            <div class="panel chat-panel">
                <div class="panel-title">Chat with Reachy</div>
                <div class="chat-messages" id="chat-messages">
                    <div class="msg msg-assistant">Hello! How can I help?</div>
                </div>
                <div class="chat-input">
                    <input type="text" id="chat-input" placeholder="Type a message...">
                    <button id="chat-send">Send</button>
                </div>
            </div>

            <!-- Tracking Data -->
            <div class="panel data-panel">
                <div class="panel-title">Live Tracking</div>
                <div class="panel-content" style="padding:0;">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Class</th>
                                <th>Score</th>
                            </tr>
                        </thead>
                        <tbody id="candidates-body"></tbody>
                    </table>
                    <div id="no-targets"
                        style="padding:16px; text-align:center; color:var(--text-muted); font-size:12px;">
                        No targets detected
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SETTINGS MODAL
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>âš™ï¸ Settings</h2>
                <button class="modal-close" id="modal-close">âœ•</button>
            </div>
            <div class="modal-tabs">
                <button class="tab-btn active" data-tab="llm-tab">LLM Models</button>
                <button class="tab-btn" data-tab="voice-tab">Voice Settings</button>
                <button class="tab-btn" data-tab="tuning-tab">Tuning</button>
                <button class="tab-btn" data-tab="system-tab">System</button>
            </div>
            
            <!-- LLM Settings Tab -->
            <div id="llm-tab" class="tab-content active">
                <div class="settings-group">
                    <h3>Language Model Provider</h3>
                    <div class="provider-selector">
                        <button class="provider-btn active" data-provider="local">ğŸ“¦ Local</button>
                        <button class="provider-btn" data-provider="ollama">ğŸ¦™ OLLAMA</button>
                        <button class="provider-btn" data-provider="openai">ğŸš€ OpenAI</button>
                    </div>
                </div>

                <!-- Local Models -->
                <div id="local-config" class="provider-config active">
                    <h4>Local Model Selection</h4>
                    <div class="settings-row">
                        <label>Current Model:</label>
                        <select id="local-model-select">
                            <option>Loading...</option>
                        </select>
                    </div>
                    <p class="info-text">ğŸ“Œ Local models run on your device without internet.</p>
                </div>

                <!-- OLLAMA Config -->
                <div id="ollama-config" class="provider-config">
                    <h4>OLLAMA Configuration</h4>
                    <div class="settings-row">
                        <label>OLLAMA Endpoint:</label>
                        <input type="text" id="ollama-endpoint" placeholder="http://localhost:11434" value="http://localhost:11434">
                    </div>
                    <div class="settings-row">
                        <label>Model:</label>
                        <select id="ollama-model-select">
                            <option>Not Connected</option>
                        </select>
                    </div>
                    <button id="ollama-test-btn" class="action-btn">Test Connection</button>
                    <p class="info-text">ğŸ“Œ OLLAMA allows you to run models locally with a server. <a href="https://ollama.ai" target="_blank">Get OLLAMA</a></p>
                </div>

                <!-- OpenAI Config -->
                <div id="openai-config" class="provider-config">
                    <h4>OpenAI API Configuration</h4>
                    <div class="settings-row">
                        <label>API Key:</label>
                        <input type="password" id="openai-key" placeholder="sk-...">
                    </div>
                    <div class="settings-row">
                        <label>Model:</label>
                        <select id="openai-model-select">
                            <option>Loading models...</option>
                        </select>
                    </div>
                    <button id="openai-test-btn" class="action-btn">Verify Key</button>
                    <p class="info-text">
                        ğŸ“Œ Get your API key at <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI API Keys</a>
                        <br>ğŸ’° View pricing at <a href="https://platform.openai.com/pricing" target="_blank">OpenAI Pricing</a>
                    </p>
                    
                    <!-- Pricing Table -->
                    <div id="pricing-container" style="display:none;">
                        <h5>Model Pricing (per 1M tokens)</h5>
                        <table class="pricing-table">
                            <thead>
                                <tr>
                                    <th>Model</th>
                                    <th>Category</th>
                                    <th>Input</th>
                                    <th>Output</th>
                                </tr>
                            </thead>
                            <tbody id="pricing-body">
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="settings-row" style="margin-top:20px;">
                    <button id="save-llm-btn" class="action-btn" style="background:var(--success); color:#000;">ğŸ’¾ Save Settings</button>
                </div>
            </div>

            <!-- Voice Settings Tab -->
            <div id="voice-tab" class="tab-content">
                <div class="settings-group">
                    <h3>Text-to-Speech Settings</h3>
                    <div class="settings-row">
                        <label>Default Volume:</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="default-volume" min="0" max="100" value="50" style="flex:1;">
                            <span id="volume-display">50%</span>
                        </div>
                    </div>
                    <div class="settings-row" style="margin-top:10px;">
                        <label style="display:flex; align-items:center; gap:8px;">
                            <span>Microphone Level</span>
                            <small id="mic-level-db" style="color:var(--text-muted);">-âˆ dB</small>
                        </label>
                        <div style="position:relative; height:10px; background:var(--bg-elevated); border-radius:5px; overflow:hidden;">
                            <div id="mic-level-bar" style="position:absolute; left:0; top:0; height:100%; width:0%; background:linear-gradient(90deg, #4ade80, #f97316, #ef4444);"></div>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Live mic input from Reachy Mini. Moves when sound is detected.</p>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>Wake Word Detection</h3>
                    <p class="info-text">ğŸ¤ Hands-free activation - say the wake word to interact without pressing buttons.</p>
                    
                    <div class="settings-row">
                        <label>
                            <input type="checkbox" id="wake-word-enabled" style="margin-right:8px;">
                            Enable Wake Word Detection
                        </label>
                    </div>
                    
                    <div class="settings-row">
                        <label>Audio Input Device:</label>
                        <select id="audio-device-select" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--surface); color:var(--text);">
                            <option value="">ğŸ”„ Loading devices...</option>
                        </select>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Select the microphone to use for wake word detection. Auto-detected: Reachy Mini Audio.</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Wake Word:</label>
                        <select id="wake-word-model" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--surface); color:var(--text);">
                            <option value="hay_ree_chee">ğŸ¤– Hay Reachy (Custom #1)</option>
                            <option value="hey_ree_shee">ğŸ¤– Hey Reachy (Custom #2)</option>
                            <option value="oh_kay_computer">ğŸ¤– Okay Computer (Custom)</option>
                            <option value="hey_jarvis">Hey Jarvis</option>
                            <option value="alexa">Alexa</option>
                            <option value="hey_mycroft">Hey Mycroft</option>
                            <option value="hey_rhasspy">Hey Rhasspy</option>
                        </select>
                    </div>
                    
                    <div class="settings-row">
                        <label>Sensitivity (Detection Threshold):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="wake-word-threshold" min="0.001" max="0.9" step="0.001" value="0.1" style="flex:1;">
                            <span id="wake-word-threshold-val" style="min-width:60px;">0.100</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Lower = more sensitive (may have false triggers), Higher = less sensitive (may miss wake word). Range: 0.001-0.900</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Listening Timeout (seconds):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="wake-word-timeout" min="3" max="15" step="1" value="5" style="flex:1;">
                            <span id="wake-word-timeout-val" style="min-width:60px;">5s</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">How long to listen for commands after wake word detected.</p>
                    </div>
                    
                    <div class="settings-row" style="margin-top:15px;">
                        <button id="save-wake-word-btn" class="action-btn" style="background:var(--success); color:#000;">ğŸ’¾ Save Wake Word Settings</button>
                    </div>
                    
                    <div id="wake-word-status" style="margin-top:10px; padding:8px; border-radius:4px; background:var(--bg-elevated); font-size:12px; display:none;">
                        <strong>Status:</strong> <span id="wake-word-status-text">Initializing...</span>
                    </div>
                </div>

                <div class="settings-group">
                    <h4>ğŸ¤ TTS Voice Selection</h4>
                    <div class="settings-row">
                        <label>Voice:</label>
                        <select id="tts-voice-select" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--surface); color:var(--text);">
                            <option value="">ğŸ”„ Loading voices...</option>
                        </select>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Select which voice the robot uses for text-to-speech. Supports 35+ languages including English, Spanish, German, French, Italian, Russian, Chinese, and many more. Voices marked with â¬‡ï¸ need to be downloaded first.</p>
                    </div>
                    
                    <div class="settings-row">
                        <button id="save-voice-btn" class="action-btn" style="background:var(--success); color:#000;">ğŸ’¾ Set Voice</button>
                        <button id="download-voice-btn" class="action-btn" style="background:#4a9eff; color:#000; margin-left:8px;">â¬‡ï¸ Download Voice</button>
                    </div>
                    
                    <div id="voice-download-progress" style="margin-top:8px; display:none; padding:8px; background:var(--surface); border-radius:4px;">
                        <div style="font-size:12px; margin-bottom:4px;">Downloading: <span id="voice-download-name"></span></div>
                        <div style="width:100%; height:6px; background:var(--border); border-radius:3px; overflow:hidden;">
                            <div id="voice-download-bar" style="width:0%; height:100%; background:var(--success); transition:width 0.2s;"></div>
                        </div>
                        <div style="font-size:10px; margin-top:4px; color:var(--muted);">Please wait...</div>
                    </div>
                    
                    <div id="voice-status" style="margin-top:10px; padding:8px; border-radius:4px; background:var(--surface); font-size:12px; display:none;">
                        <strong>Current Voice:</strong> <span id="voice-status-text">Loading...</span>
                    </div>
                </div>

                <div class="settings-group">
                    <h3>Debug Mode</h3>
                    <div class="settings-row">
                        <label style="display:flex; align-items:center; gap:8px;">
                            <input type="checkbox" id="debug-audio-enabled" style="margin-right:0;">
                            Enable Audio Debug Logging
                        </label>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Saves debug_audio_raw.wav and debug_audio_amplified.wav for troubleshooting.</p>
                    </div>
                </div>
            </div>

            <!-- Tuning Settings Tab -->
            <div id="tuning-tab" class="tab-content">
                <div class="settings-group">
                    <h3>Detection & Tracking Tuning</h3>
                    <p class="info-text">âš™ï¸ Fine-tune robot behavior and tracking performance.</p>
                    
                    <div class="settings-row">
                        <label>Detection Interval (seconds):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-detection-interval" min="0.01" max="1.0" step="0.01" value="0.20" style="flex:1;">
                            <span id="tune-detection-interval-val" style="min-width:60px;">0.20s</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">How often to run object detection (0.01-1.0s). Lower = faster detection, higher CPU.</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Command Interval (seconds):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-command-interval" min="0.1" max="5.0" step="0.1" value="1.2" style="flex:1;">
                            <span id="tune-command-interval-val" style="min-width:60px;">1.2s</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">How often to send movement commands (0.1-5.0s). Lower = smoother tracking, more movement.</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Stream FPS Cap:</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-stream-fps-cap" min="1" max="60" step="1" value="60" style="flex:1;">
                            <span id="tune-stream-fps-cap-val" style="min-width:60px;">60 FPS</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Maximum video stream frame rate (1-60 FPS). Lower = reduced bandwidth.</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Min Score Threshold:</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-min-score-threshold" min="0" max="500" step="10" value="250" style="flex:1;">
                            <span id="tune-min-score-threshold-val" style="min-width:60px;">250</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Minimum score required to track a target (0-500). Higher = more selective.</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Recenter Timeout (seconds):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-recenter-timeout" min="0.5" max="10.0" step="0.5" value="2.0" style="flex:1;">
                            <span id="tune-recenter-timeout-val" style="min-width:60px;">2.0s</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Time before recentering after losing target (0.5-10.0s).</p>
                    </div>
                    
                    <div class="settings-row" style="margin-top:20px;">
                        <button id="save-tuning-btn" class="action-btn" style="background:var(--success); color:#000;">ğŸ’¾ Save Tuning</button>
                        <button id="reset-tuning-btn" class="action-btn" style="background:var(--warning); color:#000; margin-left:10px;">ğŸ”„ Reset to Defaults</button>
                    </div>
                </div>
            </div>

            <!-- System Settings Tab -->
            <div id="system-tab" class="tab-content">
                <div class="settings-group">
                    <h3>Debug & Logging</h3>
                    <div class="settings-row">
                        <label>
                            <input type="checkbox" id="verbose-logging" style="margin-right:8px;">
                            Enable Verbose Logging
                        </label>
                        <p class="info-text">ğŸ“Œ When enabled, all API requests (including polling) are logged to the console.</p>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>Debug & Logging</h3>
                    <div class="settings-row">
                        <label>
                            <input type="checkbox" id="verbose-logging-toggle" style="margin-right:8px;">
                            Browser Console Logging
                        </label>
                        <p class="info-text">ğŸ”§ Enable detailed logging for troubleshooting and development.</p>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>About</h3>
                    <p>Reachy Control v1.0</p>
                    <p id="backend-info" style="font-size:12px; color:var(--text-muted);">Backend: Initializing...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        let isPaused = true, voiceEnabled = false, wiggleEnabled = false;  // Start paused to match server default
        let verboseLogging = localStorage.getItem('verbose_logging') === 'true';

        // Simple console logger wrapper
        const logger = {
            info: (...args) => verboseLogging && console.log('[INFO]', ...args),
            warn: (...args) => verboseLogging && console.warn('[WARN]', ...args),
            error: (...args) => verboseLogging && console.error('[ERROR]', ...args)
        };
        
        const vlog = (...args) => verboseLogging && console.log(...args);
        
        // Set up verbose logging toggle
        window.addEventListener('load', () => {
            const toggle = $('verbose-logging-toggle');
            if (toggle) {
                toggle.checked = verboseLogging;
                toggle.addEventListener('change', (e) => {
                    verboseLogging = e.target.checked;
                    localStorage.setItem('verbose_logging', verboseLogging ? 'true' : 'false');
                    vlog('[SETTINGS] Verbose logging toggled to:', verboseLogging);
                });
            }
            
            // Load voice settings on page load
            loadAvailableVoices();
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHAT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let typingIndicator = null;
        let lastTranscriptText = '';  // Track last message to prevent duplicates
        let lastResponseText = '';    // Track last response to prevent duplicates
        
        function addMsg(role, text) {
            // Prevent duplicate messages
            if (role === 'user' && text === lastTranscriptText) {
                console.log('[DUPE] Skipping duplicate user message:', text);
                return;
            }
            if (role === 'assistant' && text === lastResponseText) {
                console.log('[DUPE] Skipping duplicate assistant message:', text);
                return;
            }
            
            // Update tracking
            if (role === 'user') lastTranscriptText = text;
            if (role === 'assistant') lastResponseText = text;
            
            const el = document.createElement('div');
            el.className = `msg msg-${role}`;
            el.textContent = text;
            $('chat-messages').appendChild(el);
            $('chat-messages').scrollTop = $('chat-messages').scrollHeight;
        }
        
        function showTypingIndicator() {
            if (typingIndicator) return; // Already showing
            typingIndicator = document.createElement('div');
            typingIndicator.className = 'msg msg-typing';
            typingIndicator.innerHTML = '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>';
            $('chat-messages').appendChild(typingIndicator);
            $('chat-messages').scrollTop = $('chat-messages').scrollHeight;
        }
        
        function hideTypingIndicator() {
            if (typingIndicator) {
                typingIndicator.remove();
                typingIndicator = null;
            }
        }

        $('chat-send').onclick = async () => {
            const input = $('chat-input');
            const text = input.value.trim();
            if (!text) return;
            addMsg('user', text);
            input.value = '';
            try {
                const res = await fetch('/api/voice/text_command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text, speak: true })
                });
                const data = await res.json();
                // Don't add response here - let polling handle it to avoid duplicates
                showTypingIndicator();
            } catch (e) {
                addMsg('system', 'Error sending message');
            }
        };

        $('chat-input').onkeypress = e => { if (e.key === 'Enter') $('chat-send').click(); };

        // Ensure polling intervals are only created once
        if (!window.chatPollersInitialized) {
            window.chatPollersInitialized = true;
            
            // Poll for transcriptions and display in chat
            const transcriptionPoller = setInterval(async () => {
                try {
                    const res = await fetch('/api/voice/transcript');
                    const data = await res.json();
                    console.log('[POLL] Transcript:', data);
                    if (data.has_new && data.text) {
                        addMsg('user', data.text);
                    }
                } catch (e) {
                    console.error('[POLL] Transcript error:', e);
                }
            }, 500);

            // Poll for assistant responses and display in chat
            const responsePoller = setInterval(async () => {
                try {
                    const res = await fetch('/api/voice/response');
                    const data = await res.json();
                    console.log('[POLL] Response:', data);
                    if (data.has_new && data.text) {
                        hideTypingIndicator();
                        addMsg('assistant', data.text);
                    }
                } catch (e) {
                    console.error('[POLL] Response error:', e);
                }
            }, 500);

            // Poll for processing status to show/hide typing indicator
            const processingPoller = setInterval(async () => {
                try {
                    const res = await fetch('/api/voice/processing');
                    const data = await res.json();
                    console.log('[POLL] Processing:', data);
                    if (data.processing) {
                        showTypingIndicator();
                    } else {
                        hideTypingIndicator();
                    }
                } catch (e) {
                    console.error('[POLL] Processing error:', e);
                }
            }, 300);
            
            console.log('[INIT] Chat polling intervals initialized');
        }

        // Debug audio logging checkbox
        const debugCheckbox = $('debug-audio-enabled');
        if (debugCheckbox) {
            // Load saved state
            const savedDebug = localStorage.getItem('debug_audio_enabled') === 'true';
            debugCheckbox.checked = savedDebug;
            
            // Save on change
            debugCheckbox.addEventListener('change', async (e) => {
                const enabled = e.target.checked;
                localStorage.setItem('debug_audio_enabled', enabled ? 'true' : 'false');
                try {
                    await fetch('/api/voice/debug', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ enabled })
                    });
                    vlog('[DEBUG]', enabled ? 'Audio debug enabled' : 'Audio debug disabled');
                } catch (err) {
                    logger.error('Error setting debug mode:', err);
                }
            });
            
            // Apply saved state on load
            if (savedDebug) {
                fetch('/api/voice/debug', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: true })
                }).catch(() => {});
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ACTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        $('reset-btn').onclick = () => fetch('/api/reset', { method: 'POST' });

        $('pause-btn').onclick = async () => {
            const res = await fetch('/api/toggle_pause', { method: 'POST' });
            const data = await res.json();
            isPaused = data.paused;
            updatePauseUI();
        };

        function updatePauseUI() {
            const btn = $('pause-btn');
            const overlay = $('manual-overlay');
            vlog('[updatePauseUI] isPaused:', isPaused, 'btn exists:', !!btn, 'overlay exists:', !!overlay);
            
            if (!btn || !overlay) {
                vlog('[updatePauseUI] ERROR: DOM elements not found! btn:', btn, 'overlay:', overlay);
                return;
            }
            
            if (isPaused) {
                btn.classList.add('active');
                btn.innerHTML = '<span class="icon">â–¶ï¸</span> Resume';
                overlay.style.opacity = '1';
                overlay.style.pointerEvents = 'auto';
                vlog('[updatePauseUI] Applied PAUSED state: active=true, opacity=1');
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<span class="icon">â¸ï¸</span> Pause Tracking';
                overlay.style.opacity = '0.4';
                overlay.style.pointerEvents = 'none';
                vlog('[updatePauseUI] Applied RUNNING state: active=false, opacity=0.4');
            }
        }

        $('wiggle-btn').onclick = async () => {
            await fetch('/api/toggle_wiggle', { method: 'POST' });
        };

        async function triggerEmotion(emotion) {
            try {
                await fetch('/api/emote', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ emotion })
                });
            } catch (e) { console.error(e); }
        }

        $('voice-btn').onclick = async () => {
            const ep = voiceEnabled ? '/api/voice/disable' : '/api/voice/enable';
            const res = await fetch(ep, { method: 'POST' });
            const data = await res.json();
            voiceEnabled = data.voice_enabled;
            $('voice-btn').classList.toggle('active', voiceEnabled);
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PUSH-TO-TALK BUTTON
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const pttBtn = $('push-to-talk-btn');
        const pttStatus = $('ptt-status');
        let pttActive = false;

        pttBtn.onmousedown = pttBtn.ontouchstart = async (e) => {
            e.preventDefault();
            if (pttActive) return; // Prevent multiple triggers
            pttActive = true;
            
            // Visual feedback
            pttBtn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            pttBtn.style.transform = 'scale(0.95)';
            pttBtn.innerHTML = 'ğŸ”´ RECORDING...';
            pttStatus.textContent = 'ğŸ™ï¸ Speak now!';
            pttStatus.style.color = '#ef4444';
            
            // Trigger listening
            try {
                const res = await fetch('/api/voice/listen_now', { method: 'POST' });
                const data = await res.json();
                if (data.status !== 'ok') {
                    pttStatus.textContent = 'âš ï¸ ' + data.message;
                    resetPTT();
                }
            } catch (err) {
                pttStatus.textContent = 'âŒ Failed to start listening';
                resetPTT();
            }
        };

        pttBtn.onmouseup = pttBtn.onmouseleave = pttBtn.ontouchend = (e) => {
            if (!pttActive) return;
            e.preventDefault();
            pttStatus.textContent = 'â³ Processing...';
            setTimeout(resetPTT, 2000); // Reset after 2s
        };

        // Format wake word for display (convert oh_kay_computer -> "Okay Computer")
        function formatWakeWord(wakeWord) {
            const wakeWordNames = {
                'hay_ree_chee': 'Hay Reachy',
                'hey_ree_shee': 'Hey Reachy',
                'oh_kay_computer': 'Okay Computer',
                'hey_jarvis': 'Hey Jarvis',
                'alexa': 'Alexa',
                'hey_mycroft': 'Hey Mycroft',
                'hey_rhasspy': 'Hey Rhasspy'
            };
            return wakeWordNames[wakeWord] || wakeWord.replace(/_/g, ' ');
        }

        // Update PTT button text with current wake word
        function updatePTTButtonText() {
            const wakeWord = $('wake-word-model').value;
            const wakeWordDisplay = formatWakeWord(wakeWord);
            pttBtn.innerHTML = `ğŸ¤ Hold to Talk or Say "${wakeWordDisplay}"`;
        }

        function resetPTT() {
            pttActive = false;
            pttBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            pttBtn.style.transform = 'scale(1)';
            updatePTTButtonText();
            pttStatus.textContent = '';
        }

        // Stop speech button
        $('stop-speech-btn').onclick = async () => {
            try {
                await fetch('/api/voice/stop', { method: 'POST' });
                vlog('[VOICE] Speech stopped');
            } catch (e) {
                console.error('Failed to stop speech:', e);
            }
        };

        $('restart-btn').onclick = async () => {
            if (confirm('Restart the system? This will reload all settings and reconnect to the robot.')) {
                await fetch('/api/restart', { method: 'POST' });
                document.body.innerHTML = '<div style="display:flex;height:100vh;align-items:center;justify-content:center;color:#fff;font-family:sans-serif;"><h1>ğŸ”„ Restarting...</h1><p>Please wait, the page will reload automatically.</p></div>';
                // Wait a moment then reload
                setTimeout(() => {
                    window.location.reload();
                }, 3000);
            }
        };

        $('power-btn').onclick = async () => {
            if (confirm('Shutdown the system?')) {
                await fetch('/api/shutdown', { method: 'POST' });
                document.body.innerHTML = '<div style="display:flex;height:100vh;align-items:center;justify-content:center;color:#fff;font-family:sans-serif;"><h1>System Offline</h1></div>';
            }
        };

        window.setMotorMode = mode => {
            fetch('/api/motor_mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode })
            });
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SLIDERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const sliders = ['ant-l', 'ant-r', 'head-y', 'head-p', 'head-r', 'body-y'];
        const active = new Set();

        sliders.forEach(id => {
            const el = $(id), val = $('val-' + id);
            el.oninput = () => val.textContent = el.value + 'Â°';
            el.onmousedown = () => active.add(id);
            el.onmouseup = () => { active.delete(id); sendManual(); };
            el.ontouchstart = () => active.add(id);
            el.ontouchend = () => { active.delete(id); sendManual(); };
        });

        function sendManual() {
            if (!isPaused) return;
            fetch('/api/manual_control', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    antenna_left: +$('ant-l').value,
                    antenna_right: +$('ant-r').value,
                    head_yaw: +$('head-y').value,
                    head_pitch: +$('head-p').value,
                    head_roll: +$('head-r').value,
                    body_yaw: +$('body-y').value
                })
            });
        }

        // Volume (Main screen)
        $('volume-slider').oninput = e => $('volume-val').textContent = e.target.value + '%';
        $('volume-slider').onchange = e => {
            fetch('/api/voice/volume', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ volume: +e.target.value })
            });
        };

        // Volume (Settings menu)
        $('default-volume').oninput = e => {
            $('volume-display').textContent = e.target.value + '%';
            // Sync with main volume slider
            $('volume-slider').value = e.target.value;
            $('volume-val').textContent = e.target.value + '%';
        };
        $('default-volume').onchange = e => {
            fetch('/api/voice/volume', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ volume: +e.target.value })
            });
        };

        // Mic level polling for soundbar indicator
        function startMicLevelPolling() {
            // Use main visible bar if available, fallback to settings bar
            let bar = $('mic-level-bar-main');
            let dbLabel = $('mic-level-db-main');
            
            // Also try to update the settings version if it's loaded
            let settingsBar = $('mic-level-bar');
            let settingsDbLabel = $('mic-level-db');

            if (!bar && !settingsBar) return;

            let lastValue = 0;
            const smoothing = 0.35; // simple low-pass smoothing
            const intervalMs = 200; // 5 Hz polling

            async function poll() {
                try {
                    const resp = await fetch('/api/voice/level');
                    if (!resp.ok) throw new Error('level request failed');
                    const data = await resp.json();

                    const rms = typeof data.rms === 'number' ? data.rms : 0;
                    const db = typeof data.db === 'number' ? data.db : -Infinity;

                    const maxRms = 0.2; // clamp to typical speech RMS
                    const target = Math.max(0, Math.min(1, rms / maxRms));
                    lastValue = lastValue + smoothing * (target - lastValue);
                    const pct = Math.round(lastValue * 100);
                    
                    const dbText = Number.isFinite(db) ? `${db.toFixed(1)} dB` : '-âˆ dB';

                    // Update main bar
                    if (bar) bar.style.width = `${pct}%`;
                    if (dbLabel) dbLabel.textContent = dbText;

                    // Update settings bar (if visible)
                    if (settingsBar) settingsBar.style.width = `${pct}%`;
                    if (settingsDbLabel) settingsDbLabel.textContent = dbText;
                } catch (err) {
                    // silently ignore to keep UI calm
                }
            }

            poll();
            setInterval(poll, intervalMs);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // THEME SELECTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function initTheme() {
            const saved = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', saved);
            $('theme-select').value = saved;
        }
        
        $('theme-select').onchange = e => {
            const theme = e.target.value;
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        };
        
        initTheme();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SETTINGS MODAL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        $('settings-btn').onclick = () => $('settings-modal').classList.add('active');
        $('modal-close').onclick = () => $('settings-modal').classList.remove('active');
        
        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                btn.classList.add('active');
                $(btn.dataset.tab).classList.add('active');
            };
        });
        
        // Provider switching
        document.querySelectorAll('.provider-btn').forEach(btn => {
            btn.onclick = async () => {
                document.querySelectorAll('.provider-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.provider-config').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                const provider = btn.dataset.provider;
                $(provider + '-config').classList.add('active');
                
                // Load provider-specific data
                if (provider === 'openai') {
                    // Check if OpenAI config is already saved
                    try {
                        const res = await fetch('/api/llm/status');
                        const data = await res.json();
                        
                        if (data.provider === 'openai' && data.config.has_api_key) {
                            // Key is saved - show placeholder and load models with stored key
                            $('openai-key').placeholder = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
                            $('openai-key').value = '';
                            $('openai-key').style.opacity = '0.6';
                            
                            await loadOpenAIModels(true);
                            
                            // Pre-select the saved model
                            if (data.config.model) {
                                $('openai-model-select').value = data.config.model;
                            }
                        } else {
                            // No saved key - reset form
                            $('openai-key').placeholder = 'sk-...';
                            $('openai-key').value = '';
                            $('openai-key').style.opacity = '1';
                            loadOpenAIModels();
                        }
                    } catch (e) {
                        console.error('Error loading OpenAI config:', e);
                        loadOpenAIModels();
                    }
                } else if (provider === 'ollama') {
                    loadOLLAMAModels();
                } else if (provider === 'local') {
                    loadLocalModels();
                }
            };
        });
        
        // Load local models
        async function loadLocalModels() {
            try {
                const res = await fetch('/api/llm/models/local');
                const data = await res.json();
                const select = $('local-model-select');
                select.innerHTML = '';
                (data.models || []).forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    opt.textContent = m.name;
                    if (m.current) opt.selected = true;
                    select.appendChild(opt);
                });
            } catch (e) {
                console.error('Error loading local models:', e);
            }
        }
        
        // Load OLLAMA models
        async function loadOLLAMAModels() {
            try {
                const endpoint = $('ollama-endpoint').value;
                const res = await fetch('/api/llm/models/ollama?endpoint=' + encodeURIComponent(endpoint));
                const data = await res.json();
                const select = $('ollama-model-select');
                select.innerHTML = '';
                if (data.models && data.models.length > 0) {
                    data.models.forEach(m => {
                        const opt = document.createElement('option');
                        opt.value = m;
                        opt.textContent = m;
                        select.appendChild(opt);
                    });
                } else {
                    select.innerHTML = '<option>Not Connected</option>';
                }
            } catch (e) {
                console.error('Error loading OLLAMA models:', e);
                $('ollama-model-select').innerHTML = '<option>Connection Failed</option>';
            }
        }
        
        // Load OpenAI models
        async function loadOpenAIModels(useStoredKey = false) {
            try {
                let apiKey = $('openai-key').value;
                
                // If no key entered but one is stored, load models using backend's stored key
                if (!apiKey && useStoredKey) {
                    // Fetch models using the backend's stored key
                    const res = await fetch('/api/llm/models/openai', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ api_key: null })  // null tells backend to use stored key
                    });
                    const data = await res.json();
                    const select = $('openai-model-select');
                    select.innerHTML = '';
                    if (data.models && data.models.length > 0) {
                        data.models.forEach(m => {
                            const opt = document.createElement('option');
                            opt.value = m.id;
                            opt.textContent = m.name;
                            select.appendChild(opt);
                        });
                        
                        // Show pricing
                        if (data.pricing && data.pricing.length > 0) {
                            const tbody = $('pricing-body');
                            tbody.innerHTML = '';
                            data.pricing.forEach(p => {
                                const tr = document.createElement('tr');
                                tr.innerHTML = `<td><strong>${p.model}</strong></td><td style="font-size:11px;color:var(--accent);">${p.category}</td><td>${p.input_price}</td><td>${p.output_price}</td>`;
                                tbody.appendChild(tr);
                            });
                            $('pricing-container').style.display = 'block';
                        }
                    }
                    return;
                }
                
                if (!apiKey) {
                    $('openai-model-select').innerHTML = '<option>Enter API key first</option>';
                    return;
                }
                const res = await fetch('/api/llm/models/openai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ api_key: apiKey })
                });
                const data = await res.json();
                const select = $('openai-model-select');
                select.innerHTML = '';
                if (data.models && data.models.length > 0) {
                    data.models.forEach(m => {
                        const opt = document.createElement('option');
                        opt.value = m.id;
                        opt.textContent = m.name;
                        select.appendChild(opt);
                    });
                    
                    // Show pricing
                    if (data.pricing && data.pricing.length > 0) {
                        const tbody = $('pricing-body');
                        tbody.innerHTML = '';
                        data.pricing.forEach(p => {
                            const tr = document.createElement('tr');
                            tr.innerHTML = `<td><strong>${p.model}</strong></td><td style="font-size:11px;color:var(--accent);">${p.category}</td><td>${p.input_price}</td><td>${p.output_price}</td>`;
                            tbody.appendChild(tr);
                        });
                        $('pricing-container').style.display = 'block';
                    }
                } else {
                    select.innerHTML = '<option>Error: Invalid API key</option>';
                }
            } catch (e) {
                console.error('Error loading OpenAI models:', e);
                $('openai-model-select').innerHTML = '<option>Error loading models</option>';
            }
        }
        
        // Test buttons
        $('ollama-test-btn').onclick = () => {
            loadOLLAMAModels();
        };
        
        $('openai-test-btn').onclick = async () => {
            const apiKey = $('openai-key').value;
            if (!apiKey) {
                alert('Please enter your API key');
                return;
            }
            try {
                const res = await fetch('/api/llm/validate-key', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ api_key: apiKey, provider: 'openai' })
                });
                const data = await res.json();
                if (data.valid) {
                    alert('âœ… API key is valid!');
                    loadOpenAIModels();
                } else {
                    alert('âŒ API key is invalid: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error verifying key: ' + e.message);
            }
        };
        
        // Save settings
        $('save-llm-btn').onclick = async () => {
            const provider = document.querySelector('.provider-btn.active').dataset.provider;
            const config = {};
            
            if (provider === 'local') {
                config.model_id = $('local-model-select').value;
            } else if (provider === 'ollama') {
                config.endpoint = $('ollama-endpoint').value;
                config.model = $('ollama-model-select').value;
            } else if (provider === 'openai') {
                config.api_key = $('openai-key').value;
                config.model = $('openai-model-select').value;
            }
            
            try {
                const res = await fetch('/api/llm/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ provider, config })
                });
                const data = await res.json();
                if (data.success) {
                    alert('âœ… Settings saved successfully!');
                    $('settings-modal').classList.remove('active');
                } else {
                    alert('âŒ Error saving settings: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error: ' + e.message);
            }
        };
        
        // Load initial data
        loadLocalModels();
        
        // Load saved LLM configuration on page load
        async function loadSavedLLMConfig() {
            try {
                const res = await fetch('/api/llm/status');
                const data = await res.json();
                
                if (data.provider) {
                    // Set the active provider button
                    document.querySelectorAll('.provider-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.provider === data.provider) {
                            btn.classList.add('active');
                        }
                    });
                    
                    // Show the correct provider config
                    document.querySelectorAll('.provider-config').forEach(cfg => cfg.classList.remove('active'));
                    $(data.provider + '-config').classList.add('active');
                    
                    // Populate saved settings
                    if (data.provider === 'local' && data.config.model_id) {
                        $('local-model-select').value = data.config.model_id;
                    } else if (data.provider === 'ollama') {
                        if (data.config.endpoint) $('ollama-endpoint').value = data.config.endpoint;
                        if (data.config.model) $('ollama-model-select').value = data.config.model;
                    } else if (data.provider === 'openai') {
                        // Show placeholder if API key is already saved
                        if (data.config.has_api_key) {
                            $('openai-key').placeholder = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
                            $('openai-key').value = '';
                            $('openai-key').style.opacity = '0.6';
                            
                            // Load OpenAI models using stored key
                            await loadOpenAIModels(true);
                            
                            // Set the selected model
                            if (data.config.model) {
                                $('openai-model-select').value = data.config.model;
                            }
                        }
                    }
                    
                    logger.info(`Loaded LLM config: provider=${data.provider}`);
                }
            } catch (e) {
                console.error('Error loading LLM config:', e);
            }
        }
        
        loadSavedLLMConfig();
        
        // Verbose logging toggle
        function initVerboseLogging() {
            const saved = localStorage.getItem('verbose-logging') === 'true';
            $('verbose-logging').checked = saved;
            sendVerboseSetting(saved);
        }
        
        $('verbose-logging').onchange = e => {
            const enabled = e.target.checked;
            localStorage.setItem('verbose-logging', enabled);
            sendVerboseSetting(enabled);
        };
        
        async function sendVerboseSetting(enabled) {
            try {
                await fetch('/api/settings/verbose', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ verbose: enabled })
                });
            } catch (e) {
                console.error('Error setting verbose logging:', e);
            }
        }
        
        initVerboseLogging();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TUNING SETTINGS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const tuningParams = [
            { id: 'detection-interval', key: 'detection_interval', suffix: 's', decimals: 2 },
            { id: 'command-interval', key: 'command_interval', suffix: 's', decimals: 1 },
            { id: 'stream-fps-cap', key: 'stream_fps_cap', suffix: ' FPS', decimals: 0 },
            { id: 'min-score-threshold', key: 'min_score_threshold', suffix: '', decimals: 0 },
            { id: 'recenter-timeout', key: 'recenter_timeout', suffix: 's', decimals: 1 }
        ];
        
        // Initialize tuning controls
        tuningParams.forEach(param => {
            const slider = $('tune-' + param.id);
            const display = $('tune-' + param.id + '-val');
            
            slider.oninput = () => {
                const val = parseFloat(slider.value);
                display.textContent = val.toFixed(param.decimals) + param.suffix;
            };
        });
        
        // Load current tuning values
        async function loadTuningSettings() {
            try {
                // Try to load from localStorage first (for persistence across page reloads)
                const savedTuning = localStorage.getItem('tuning-settings');
                let data = null;
                
                if (savedTuning) {
                    try {
                        data = JSON.parse(savedTuning);
                        logger.info('Loaded tuning from localStorage');
                    } catch (e) {
                        logger.warn('Invalid localStorage tuning data, fetching from server');
                    }
                }
                
                // Fetch from server (authoritative source)
                const res = await fetch('/api/tuning');
                if (res.ok) {
                    data = await res.json();
                    // Update localStorage with server values
                    localStorage.setItem('tuning-settings', JSON.stringify(data));
                }
                
                if (data) {
                    tuningParams.forEach(param => {
                        const slider = $('tune-' + param.id);
                        const display = $('tune-' + param.id + '-val');
                        const value = data[param.key];
                        
                        if (value !== undefined) {
                            slider.value = value;
                            display.textContent = parseFloat(value).toFixed(param.decimals) + param.suffix;
                        }
                    });
                    
                    logger.info('Loaded tuning settings');
                }
            } catch (e) {
                console.error('Error loading tuning settings:', e);
            }
        }
        
        // Save tuning settings
        $('save-tuning-btn').onclick = async () => {
            const tuning = {};
            tuningParams.forEach(param => {
                const slider = $('tune-' + param.id);
                tuning[param.key] = parseFloat(slider.value);
            });
            
            try {
                const res = await fetch('/api/tuning', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(tuning)
                });
                
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                
                const data = await res.json();
                
                // Save to localStorage for persistence
                localStorage.setItem('tuning-settings', JSON.stringify(tuning));
                
                if (data.warnings && data.warnings.length > 0) {
                    alert('âš ï¸ Tuning saved with warnings:\n' + data.warnings.join('\n'));
                } else {
                    alert('âœ… Tuning settings saved successfully!');
                }
                
                logger.info('Saved tuning settings:', tuning);
            } catch (e) {
                console.error('Error saving tuning:', e);
                alert('âŒ Error saving tuning settings: ' + e.message);
            }
        };
        
        // Reset to defaults
        $('reset-tuning-btn').onclick = async () => {
            if (!confirm('Reset all tuning parameters to defaults?')) return;
            
            const defaults = {
                detection_interval: 0.20,
                command_interval: 1.2,
                stream_fps_cap: 60.0,
                min_score_threshold: 250.0,
                recenter_timeout: 2.0
            };
            
            try {
                const res = await fetch('/api/tuning', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(defaults)
                });
                
                await loadTuningSettings(); // Reload values
                alert('âœ… Tuning reset to defaults!');
                logger.info('Reset tuning to defaults');
            } catch (e) {
                console.error('Error resetting tuning:', e);
                alert('âŒ Error resetting tuning settings');
            }
        };
        
        // Load tuning on page load
        loadTuningSettings();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WAKE WORD DETECTION SETTINGS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function loadAudioDevices() {
            try {
                const res = await fetch('/api/voice/audio-devices');
                const data = await res.json();
                
                if (!data.devices || data.devices.length === 0) {
                    $('audio-device-select').innerHTML = '<option value="">No audio devices found</option>';
                    return;
                }
                
                // Build device options
                let html = '';
                data.devices.forEach(device => {
                    const selected = device.is_selected ? ' selected' : '';
                    const marker = device.is_default ? ' (System Default)' : '';
                    html += `<option value="${device.id}"${selected}>${device.name}${marker}</option>`;
                });
                
                $('audio-device-select').innerHTML = html;
                vlog('Audio devices loaded:', data.devices);
            } catch (e) {
                console.error('Error loading audio devices:', e);
                $('audio-device-select').innerHTML = '<option value="">Error loading devices</option>';
            }
        }
        
        async function loadWakeWordSettings() {
            try {
                const res = await fetch('/api/voice/wake-word/status');
                const data = await res.json();
                
                $('wake-word-enabled').checked = data.enabled || false;
                $('wake-word-model').value = data.wake_word || 'hey_jarvis';
                $('wake-word-threshold').value = data.threshold || 0.1;
                $('wake-word-threshold-val').textContent = (data.threshold || 0.1).toFixed(3);
                $('wake-word-timeout').value = data.timeout || 5;
                $('wake-word-timeout-val').textContent = (data.timeout || 5) + 's';
                
                // Update PTT button text with current wake word
                updatePTTButtonText();
                
                // Show status
                $('wake-word-status').style.display = 'block';
                const modelStatus = data.model_loaded ? 'âœ… Loaded' : 'â³ Not loaded';
                $('wake-word-status-text').textContent = `${data.enabled ? 'Enabled' : 'Disabled'} | Model: ${modelStatus}`;
                
                // Also load audio devices
                await loadAudioDevices();
                
                logger.info('Wake word settings loaded:', data);
            } catch (e) {
                console.error('Error loading wake word settings:', e);
            }
        }
        
        // Update threshold display in real-time
        $('wake-word-threshold').oninput = () => {
            $('wake-word-threshold-val').textContent = parseFloat($('wake-word-threshold').value).toFixed(3);
        };
        
        // Update timeout display in real-time
        $('wake-word-timeout').oninput = () => {
            $('wake-word-timeout-val').textContent = $('wake-word-timeout').value + 's';
        };
        
        // Update PTT button when wake word model changes
        $('wake-word-model').onchange = () => {
            updatePTTButtonText();
        };
        
        // Save wake word settings
        $('save-wake-word-btn').onclick = async () => {
            try {
                const deviceId = $('audio-device-select').value;
                const settings = {
                    enabled: $('wake-word-enabled').checked,
                    wake_word: $('wake-word-model').value,
                    threshold: parseFloat($('wake-word-threshold').value),
                    timeout: parseFloat($('wake-word-timeout').value)
                };
                
                // Include device ID if one is selected
                if (deviceId) {
                    settings.audio_device_id = parseInt(deviceId);
                }
                
                const res = await fetch('/api/voice/wake-word/configure', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(settings)
                });
                
                const data = await res.json();
                if (data.status === 'ok') {
                    await loadWakeWordSettings(); // Reload to confirm
                    alert('âœ… Wake word settings saved! Changes will apply when voice assistant is next enabled.');
                    logger.info('Wake word settings saved:', settings);
                } else {
                    alert('âŒ Error: ' + (data.message || 'Unknown error'));
                }
            } catch (e) {
                console.error('Error saving wake word settings:', e);
                alert('âŒ Error saving wake word settings');
            }
        };
        
        // Load wake word settings when voice tab is opened
        document.querySelector('[data-tab="voice-tab"]').addEventListener('click', loadWakeWordSettings);
        
        // Load and manage TTS voices
        async function loadAvailableVoices() {
            try {
                const res = await fetch('/api/voice/voices');
                const data = await res.json();
                
                if (data.status === 'ok') {
                    const voiceSelect = $('tts-voice-select');
                    voiceSelect.innerHTML = '';
                    
                    // Use voice catalog with download status
                    const catalog = data.voice_catalog || {};
                    
                    // Helper to format voice name for display
                    const formatVoiceName = (voice) => {
                        // Format: en_US-name-variant -> Name Variant
                        const parts = voice.split('-').slice(1);
                        return parts.map(p => p.replace(/\b\w/g, l => l.toUpperCase())).join(' ');
                    };
                    
                    // Language labels with flags
                    const languageLabels = {
                        'en_US': 'ğŸ‡ºğŸ‡¸ English (US)',
                        'en_GB': 'ğŸ‡¬ğŸ‡§ English (GB)',
                        'ar_JO': 'ğŸ‡¯ğŸ‡´ Arabic (Jordan)',
                        'bg_BG': 'ğŸ‡§ğŸ‡¬ Bulgarian',
                        'ca_ES': 'ğŸ‡ªğŸ‡¸ Catalan',
                        'cs_CZ': 'ğŸ‡¨ğŸ‡¿ Czech',
                        'cy_GB': 'ğŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿ Welsh',
                        'da_DK': 'ğŸ‡©ğŸ‡° Danish',
                        'de_DE': 'ğŸ‡©ğŸ‡ª German',
                        'el_GR': 'ğŸ‡¬ğŸ‡· Greek',
                        'es_AR': 'ğŸ‡¦ğŸ‡· Spanish (Argentina)',
                        'es_ES': 'ğŸ‡ªğŸ‡¸ Spanish (Spain)',
                        'es_MX': 'ğŸ‡²ğŸ‡½ Spanish (Mexico)',
                        'fa_IR': 'ğŸ‡®ğŸ‡· Persian',
                        'fi_FI': 'ğŸ‡«ğŸ‡® Finnish',
                        'fr_FR': 'ğŸ‡«ğŸ‡· French',
                        'he_IL': 'ğŸ‡®ğŸ‡± Hebrew',
                        'hi_IN': 'ğŸ‡®ğŸ‡³ Hindi',
                        'hu_HU': 'ğŸ‡­ğŸ‡º Hungarian',
                        'id_ID': 'ğŸ‡®ğŸ‡© Indonesian',
                        'is_IS': 'ğŸ‡®ğŸ‡¸ Icelandic',
                        'it_IT': 'ğŸ‡®ğŸ‡¹ Italian',
                        'ka_GE': 'ğŸ‡¬ğŸ‡ª Georgian',
                        'kk_KZ': 'ğŸ‡°ğŸ‡¿ Kazakh',
                        'lb_LU': 'ğŸ‡±ğŸ‡º Luxembourgish',
                        'lv_LV': 'ğŸ‡±ğŸ‡» Latvian',
                        'ml_IN': 'ğŸ‡®ğŸ‡³ Malayalam',
                        'ne_NP': 'ğŸ‡³ğŸ‡µ Nepali',
                        'nl_BE': 'ğŸ‡§ğŸ‡ª Dutch (Belgium)',
                        'nl_NL': 'ğŸ‡³ğŸ‡± Dutch (Netherlands)',
                        'no_NO': 'ğŸ‡³ğŸ‡´ Norwegian',
                        'pl_PL': 'ğŸ‡µğŸ‡± Polish',
                        'pt_BR': 'ğŸ‡§ğŸ‡· Portuguese (Brazil)',
                        'pt_PT': 'ğŸ‡µğŸ‡¹ Portuguese (Portugal)',
                        'ro_RO': 'ğŸ‡·ğŸ‡´ Romanian',
                        'ru_RU': 'ğŸ‡·ğŸ‡º Russian',
                        'sk_SK': 'ğŸ‡¸ğŸ‡° Slovak',
                        'sl_SI': 'ğŸ‡¸ğŸ‡® Slovenian',
                        'sr_RS': 'ğŸ‡·ğŸ‡¸ Serbian',
                        'sv_SE': 'ğŸ‡¸ğŸ‡ª Swedish',
                        'sw_CD': 'ğŸ‡¨ğŸ‡© Swahili (Congo)',
                        'te_IN': 'ğŸ‡®ğŸ‡³ Telugu',
                        'tr_TR': 'ğŸ‡¹ğŸ‡· Turkish',
                        'uk_UA': 'ğŸ‡ºğŸ‡¦ Ukrainian',
                        'vi_VN': 'ğŸ‡»ğŸ‡³ Vietnamese',
                        'zh_CN': 'ğŸ‡¨ğŸ‡³ Chinese (Mandarin)',
                    };
                    
                    // Sort languages by country name, then alphabetically
                    const sortedLanguages = Object.keys(catalog).sort((a, b) => {
                        const labelA = languageLabels[a] || a;
                        const labelB = languageLabels[b] || b;
                        
                        // Extract country name (after the flag emoji and space)
                        const countryA = labelA.replace(/^[\p{Emoji}]+\s*/, '').split('(')[0].trim();
                        const countryB = labelB.replace(/^[\p{Emoji}]+\s*/, '').split('(')[0].trim();
                        
                        // First sort by country name
                        const countryCompare = countryA.localeCompare(countryB);
                        if (countryCompare !== 0) return countryCompare;
                        
                        // Then sort by language code within same country
                        return a.localeCompare(b);
                    });
                    
                    // Add voice groups for each language
                    sortedLanguages.forEach(langCode => {
                        const voices = catalog[langCode];
                        if (voices && voices.length > 0) {
                            const group = document.createElement('optgroup');
                            group.label = languageLabels[langCode] || langCode;
                            
                            voices.forEach(voiceInfo => {
                                const opt = document.createElement('option');
                                opt.value = voiceInfo.name;
                                const displayName = formatVoiceName(voiceInfo.name);
                                opt.textContent = voiceInfo.downloaded 
                                    ? `${displayName}` 
                                    : `${displayName} â¬‡ï¸`;
                                if (voiceInfo.name === data.selected_voice) opt.selected = true;
                                group.appendChild(opt);
                            });
                            
                            voiceSelect.appendChild(group);
                        }
                    });
                    
                    // Update status display
                    $('voice-status').style.display = 'block';
                    $('voice-status-text').textContent = data.selected_voice || 'None';
                    
                    logger.info('Voice catalog loaded:', catalog);
                } else {
                    console.error('Error loading voices:', data.message);
                    $('tts-voice-select').innerHTML = '<option>Error loading voices</option>';
                }
            } catch (e) {
                console.error('Error loading available voices:', e);
                $('tts-voice-select').innerHTML = '<option>Error loading voices</option>';
            }
        }
        
        // Set voice
        $('save-voice-btn').onclick = async () => {
            const voiceName = $('tts-voice-select').value;
            if (!voiceName) {
                alert('âŒ Please select a voice');
                return;
            }
            
            try {
                const res = await fetch('/api/voice/voices/set', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ voice: voiceName })
                });
                
                const data = await res.json();
                if (data.status === 'ok') {
                    await loadAvailableVoices();
                    alert('âœ… Voice changed to: ' + voiceName);
                    logger.info('Voice set to:', voiceName);
                } else {
                    // Voice might not be downloaded yet
                    if (data.message && data.message.includes('not found')) {
                        const shouldDownload = confirm('Voice not downloaded. Download it now?');
                        if (shouldDownload) {
                            // Download and then set the voice
                            await downloadAndSetVoice(voiceName, true);
                        }
                    } else {
                        alert('âŒ Error: ' + (data.message || 'Unknown error'));
                    }
                }
            } catch (e) {
                console.error('Error setting voice:', e);
                alert('âŒ Error setting voice');
            }
        };
        
        // Download voice helper function
        async function downloadAndSetVoice(voiceName, autoSet = false) {
            const progressDiv = $('voice-download-progress');
            const progressBar = $('voice-download-bar');
            const progressName = $('voice-download-name');
            
            progressDiv.style.display = 'block';
            progressBar.style.width = '0%';
            progressName.textContent = voiceName;
            
            try {
                const res = await fetch('/api/voice/voices/download', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ voice: voiceName })
                });
                
                const data = await res.json();
                
                if (data.status === 'ok') {
                    progressBar.style.width = '100%';
                    await new Promise(r => setTimeout(r, 500));  // Brief delay to show completion
                    progressDiv.style.display = 'none';
                    await loadAvailableVoices();
                    
                    // Auto-set voice if requested
                    if (autoSet) {
                        const setRes = await fetch('/api/voice/voices/set', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ voice: voiceName })
                        });
                        const setData = await setRes.json();
                        if (setData.status === 'ok') {
                            await loadAvailableVoices();
                            alert('âœ… Downloaded and set voice to: ' + voiceName);
                            logger.info('Voice downloaded and set to:', voiceName);
                        } else {
                            alert('âœ… Downloaded but failed to set: ' + voiceName);
                        }
                    } else {
                        alert('âœ… ' + data.message);
                        logger.info('Voice downloaded:', voiceName);
                    }
                } else {
                    progressDiv.style.display = 'none';
                    alert('âŒ Error: ' + (data.message || 'Unknown error'));
                }
            } catch (e) {
                progressDiv.style.display = 'none';
                console.error('Error downloading voice:', e);
                alert('âŒ Error downloading voice: ' + e.message);
            }
        }
        
        // Download voice button handler
        $('download-voice-btn').onclick = async () => {
            const voiceName = $('tts-voice-select').value;
            if (!voiceName) {
                alert('âŒ Please select a voice to download');
                return;
            }
            await downloadAndSetVoice(voiceName, false);
        };
        
        // Load voices when voice settings tab is opened
        document.querySelector('[data-tab="voice-tab"]').addEventListener('click', async () => {
            await loadWakeWordSettings();
            await loadAvailableVoices();
        });
        
        // Initial load when page loads (if voice tab is already open)
        loadWakeWordSettings();
        startMicLevelPolling();

         // Test mic level API
         $('test-mic-level-btn').onclick = async () => {
             try {
                 const resp = await fetch('/api/voice/level');
                 const data = await resp.json();
                 console.log('Mic level API response:', data);
                 alert(`API Response:\nRMS: ${data.rms?.toFixed(4) || 'N/A'}\ndB: ${data.db?.toFixed(1) || 'N/A'}`);
                 
                 // Test bar rendering: set to 50%
                 const bar = $('mic-level-bar-main');
                 if (bar) {
                     bar.style.width = '50%';
                     console.log('Bar set to 50% for testing');
                 } else {
                     console.warn('Bar element not found');
                 }
             } catch (err) {
                 alert('Error fetching mic level: ' + err.message);
                 console.error(err);
             }
         };
        let nyanAnimationId = null;
        let nyanCanvas = null;
        let nyanCtx = null;
        
        function initNyanCat() {
            const theme = document.documentElement.getAttribute('data-theme');
            if (theme !== 'nyan') {
                cleanupNyanCat();
                return;
            }
            
            // Create canvas
            if (!nyanCanvas) {
                nyanCanvas = document.createElement('canvas');
                nyanCanvas.id = 'nyan-canvas';
                nyanCanvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 9997;
                `;
                document.body.appendChild(nyanCanvas);
                nyanCtx = nyanCanvas.getContext('2d');
                
                // Set canvas size
                function resizeCanvas() {
                    nyanCanvas.width = window.innerWidth;
                    nyanCanvas.height = window.innerHeight;
                }
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }
            
            const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#8b00ff'];
            const trail = [];
            let time = 0;
            
            function drawNyanCat() {
                const theme = document.documentElement.getAttribute('data-theme');
                if (theme !== 'nyan') {
                    cleanupNyanCat();
                    return;
                }
                
                // Clear canvas
                nyanCtx.clearRect(0, 0, nyanCanvas.width, nyanCanvas.height);
                
                time += 16;
                const duration = 8000;
                const progress = (time % duration) / duration;
                
                // Cat position
                const catX = -50 + (nyanCanvas.width + 100) * progress;
                let yPercent;
                if (progress < 0.25) {
                    yPercent = 0.20 + (0.30 - 0.20) * (progress / 0.25);
                } else if (progress < 0.5) {
                    yPercent = 0.30 + (0.25 - 0.30) * ((progress - 0.25) / 0.25);
                } else if (progress < 0.75) {
                    yPercent = 0.25 + (0.35 - 0.25) * ((progress - 0.5) / 0.25);
                } else {
                    yPercent = 0.35 + (0.20 - 0.35) * ((progress - 0.75) / 0.25);
                }
                const catY = nyanCanvas.height * yPercent;
                
                // Add trail point
                trail.push({ x: catX, y: catY, time: Date.now() });
                
                // Remove old trail points
                const now = Date.now();
                while (trail.length > 0 && now - trail[0].time > 2000) {
                    trail.shift();
                }
                
                // Draw rainbow trail
                const stripeHeight = 8;
                const totalHeight = colors.length * stripeHeight;
                
                for (let i = 0; i < trail.length - 1; i++) {
                    const p1 = trail[i];
                    const p2 = trail[i + 1];
                    const age = (now - p1.time) / 2000;
                    const opacity = 1 - age;
                    
                    if (opacity > 0) {
                        colors.forEach((color, colorIdx) => {
                            nyanCtx.strokeStyle = color;
                            nyanCtx.lineWidth = stripeHeight;
                            nyanCtx.globalAlpha = opacity * 0.9;
                            nyanCtx.shadowBlur = 10;
                            nyanCtx.shadowColor = color;
                            
                            nyanCtx.beginPath();
                            nyanCtx.moveTo(p1.x, p1.y + colorIdx * stripeHeight - totalHeight/2);
                            nyanCtx.lineTo(p2.x, p2.y + colorIdx * stripeHeight - totalHeight/2);
                            nyanCtx.stroke();
                        });
                    }
                }
                
                // Reset shadow
                nyanCtx.shadowBlur = 0;
                nyanCtx.globalAlpha = 1;
                
                // Draw cat emoji
                nyanCtx.font = '48px Arial';
                nyanCtx.filter = 'drop-shadow(0 0 10px rgba(255, 102, 204, 0.8))';
                nyanCtx.fillText('ğŸ±', catX, catY);
                nyanCtx.filter = 'none';
                
                nyanAnimationId = requestAnimationFrame(drawNyanCat);
            }
            
            drawNyanCat();
        }
        
        function cleanupNyanCat() {
            if (nyanAnimationId) {
                cancelAnimationFrame(nyanAnimationId);
                nyanAnimationId = null;
            }
            if (nyanCanvas && nyanCanvas.parentNode) {
                nyanCanvas.parentNode.removeChild(nyanCanvas);
                nyanCanvas = null;
                nyanCtx = null;
            }
        }
        
        // Initialize on theme change
        const themeSelect = document.getElementById('theme-select');
        const originalThemeChange = themeSelect.onchange;
        themeSelect.onchange = function(e) {
            if (originalThemeChange) originalThemeChange.call(this, e);
            setTimeout(initNyanCat, 100);
        };
        
        // Initialize if already on nyan theme
        initNyanCat();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POLLING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function refreshStatus() {
            try {
                const res = await fetch('/status');
                const data = await res.json();

                // Status
                $('status-text').textContent = data.status || 'Ready';
                
                // Backend info
                if (data.backend) {
                    const robotStatus = data.backend.robot_connected ? 'âœ… Connected' : 'âŒ Disconnected';
                    const voiceStatus = data.backend.voice_enabled ? 'ğŸ¤ Enabled' : 'ğŸ”‡ Disabled';
                    $('backend-info').innerHTML = `Backend: Python ${data.backend.python_version} | Robot: ${robotStatus} | Voice: ${voiceStatus}`;
                }

                // Wiggle
                wiggleEnabled = data.wiggle_enabled;
                $('wiggle-btn').classList.toggle('active', wiggleEnabled);

                // Pause sync
                if (data.paused !== undefined) {
                    isPaused = data.paused;
                    updatePauseUI();
                }

                // Candidates
                const tbody = $('candidates-body');
                const noT = $('no-targets');
                if (data.candidates?.length) {
                    noT.style.display = 'none';
                    tbody.innerHTML = '';
                    data.candidates.sort((a, b) => b.score - a.score).slice(0, 5).forEach(c => {
                        const tr = document.createElement('tr');
                        if (c.id == data.current_target_id) tr.classList.add('active');
                        tr.innerHTML = `<td>#${c.id}</td><td>${c.label}</td><td>${Math.round(c.score)}</td>`;
                        tbody.appendChild(tr);
                    });
                } else {
                    tbody.innerHTML = '';
                    noT.style.display = 'block';
                }

                // Slider sync
                if (data.pose) {
                    const deg = r => (r * 180 / Math.PI);
                    const map = {
                        'ant-l': data.pose.antenna_left,
                        'ant-r': data.pose.antenna_right,
                        'head-y': deg(data.pose.head_yaw),
                        'head-p': deg(data.pose.head_pitch),
                        'head-r': deg(data.pose.head_roll),
                        'body-y': deg(data.pose.body_yaw)
                    };
                    for (const [id, v] of Object.entries(map)) {
                        if (!active.has(id)) {
                            $(id).value = v;
                            $('val-' + id).textContent = Math.round(v) + 'Â°';
                        }
                    }
                }

                // Voice polling
                if (voiceEnabled) {
                    const vr = await fetch('/api/voice/status');
                    const vd = await vr.json();
                    if (vd.conversation_history?.length) {
                        const last = vd.conversation_history[vd.conversation_history.length - 1];
                        if (last.role === 'assistant' && window.lastA !== last.content) {
                            window.lastA = last.content;
                            addMsg('assistant', last.content);
                        }
                    }
                }
            } catch (e) { }
        }
        
        // Initial status fetch on page load
        async function initializePageState() {
            vlog('[initializePageState] Starting async fetch...');
            try {
                const res = await fetch('/status');
                const data = await res.json();
                
                // Set initial pause state from server
                if (data.paused !== undefined) {
                    isPaused = data.paused;
                    vlog('[initializePageState] Fetched server state: paused =', isPaused);
                } else {
                    vlog('[initializePageState] Server did not return paused state');
                }
            } catch (e) {
                console.error('[initializePageState] Failed to fetch:', e);
            }
            // Always update UI after fetching (or on failure with default)
            vlog('[initializePageState] Calling updatePauseUI after server fetch');
            updatePauseUI();
        }
        
        // Wait for DOM to be fully loaded before running initialization
        function startInitialization() {
            vlog('[INIT] DOM Ready. isPaused =', isPaused);
            vlog('[INIT] DOM check - pause-btn:', !!document.getElementById('pause-btn'), 'manual-overlay:', !!document.getElementById('manual-overlay'));
            
            vlog('[INIT] Calling updatePauseUI immediately');
            updatePauseUI();
            
            vlog('[INIT] Calling initializePageState async');
            initializePageState();
            
            // Poll every 500ms
            setInterval(refreshStatus, 500);
        }
        
        // Run on page load
        if (document.readyState === 'loading') {
            vlog('[INIT] Document still loading, waiting for DOMContentLoaded...');
            document.addEventListener('DOMContentLoaded', startInitialization);
        } else {
            vlog('[INIT] Document already loaded, starting immediately...');
            startInitialization();
        }
    </script>
</body>

</html>