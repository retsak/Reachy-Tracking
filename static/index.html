<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reachy Control</title>
    <link rel="stylesheet" href="/static/style.css?v=2">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü§ñ</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div class="dashboard">
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         HEADER
         ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <header class="header">
            <h1>ü§ñ Reachy Control</h1>
            <div class="header-controls">
                <div class="theme-selector">
                    <label for="theme-select">üé®</label>
                    <select id="theme-select">
                        <option value="dark">Dark</option>
                        <option value="light">Light</option>
                        <option value="ocean">Ocean</option>
                        <option value="forest">Forest</option>
                        <option value="hacker">Hacker</option>
                        <option value="halloween">Halloween</option>
                        <option value="christmas">Christmas</option>
                        <option value="newyear">New Year</option>
                        <option value="sunset">Sunset</option>
                        <option value="cyberpunk">Cyberpunk</option>
                        <option value="midnight">Midnight</option>
                        <option value="lavender">Lavender</option>
                        <option value="retro">Retro</option>
                        <option value="arctic">Arctic</option>
                        <option value="volcano">Volcano</option>
                        <option value="synthwave">Synthwave</option>
                        <option value="coffee">Coffee</option>
                        <option value="cherry">Cherry</option>
                        <option value="unicorn">ü¶Ñ Unicorn Barf</option>
                        <option value="nyan">üê± Nyan Cat</option>
                    </select>
                </div>
                <button class="header-btn" id="settings-btn" title="Settings">‚öôÔ∏è</button>
                <div class="header-status">
                    <span><span class="status-dot"></span><span id="status-text">Ready</span></span>
                    <span>üîå Connected</span>
                </div>
            </div>
        </header>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         LEFT SIDEBAR - Quick Actions
         ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <div class="panel sidebar-left">
            <div class="panel-title">Quick Actions</div>
            <div class="panel-content">
                <div class="action-list">
                    <button class="action-btn" id="wiggle-btn">
                        <span class="icon">üé≠</span> Wiggle Mode
                    </button>
                    <button class="action-btn" id="pause-btn">
                        <span class="icon">‚è∏Ô∏è</span> Pause Tracking
                    </button>
                    <button class="action-btn" id="reset-btn">
                        <span class="icon">üîÑ</span> Reset Position
                    </button>
                    <button class="action-btn" id="voice-btn">
                        <span class="icon">üé§</span> Voice Assistant
                    </button>
                </div>

                <div style="margin-top:24px;">
                    <div class="panel-title" style="padding:0; border:none; margin-bottom:12px;">Motor Mode</div>
                    <div class="action-list">
                        <button class="action-btn" onclick="setMotorMode('stiff')">
                            <span class="icon">üí™</span> Stiff
                        </button>
                        <button class="action-btn" onclick="setMotorMode('soft')">
                            <span class="icon">‚òÅÔ∏è</span> Soft
                        </button>
                        <button class="action-btn" onclick="setMotorMode('limp')">
                            <span class="icon">üí§</span> Limp
                        </button>
                    </div>
                </div>

                <div style="margin-top:auto; padding-top:24px; display:flex; flex-direction:column; gap:8px;">
                    <button class="action-btn" id="restart-btn" style="background:#FFA500; color:#000;">
                        <span class="icon">üîÑ</span> Restart
                    </button>
                    <button class="action-btn danger" id="power-btn">
                        <span class="icon">‚õî</span> Shutdown
                    </button>
                </div>
            </div>
        </div>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         CENTER - Video + Manual Controls
         ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <div class="main-center">
            <!-- Video Panel - COMPACT -->
            <div class="panel video-panel">
                <div class="video-frame">
                    <img src="/video_feed" alt="Video Feed" id="video-feed">
                    <div class="video-label">LIVE FEED</div>
                </div>
            </div>

            <!-- Manual Controls -->
            <div class="panel controls-panel">
                <div class="panel-title">Manual Control</div>
                <div class="panel-content">
                    <div id="manual-overlay" style="opacity:0.4; pointer-events:none;">
                        <div class="control-grid">
                        <div class="control-group">
                            <h4>Antennas</h4>
                            <div class="slider-row">
                                <div class="slider-label"><span>Left</span><span class="slider-val"
                                        id="val-ant-l">0¬∞</span></div>
                                <input type="range" id="ant-l" min="-180" max="180" value="0">
                            </div>
                            <div class="slider-row">
                                <div class="slider-label"><span>Right</span><span class="slider-val"
                                        id="val-ant-r">0¬∞</span></div>
                                <input type="range" id="ant-r" min="-180" max="180" value="0">
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Head</h4>
                            <div class="slider-row">
                                <div class="slider-label"><span>Yaw</span><span class="slider-val"
                                        id="val-head-y">0¬∞</span></div>
                                <input type="range" id="head-y" min="-90" max="90" value="0">
                            </div>
                            <div class="slider-row">
                                <div class="slider-label"><span>Pitch</span><span class="slider-val"
                                        id="val-head-p">0¬∞</span></div>
                                <input type="range" id="head-p" min="-45" max="45" value="0">
                            </div>
                            <div class="slider-row">
                                <div class="slider-label"><span>Roll</span><span class="slider-val"
                                        id="val-head-r">0¬∞</span></div>
                                <input type="range" id="head-r" min="-45" max="45" value="0">
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Body</h4>
                            <div class="slider-row">
                                <div class="slider-label"><span>Body Yaw</span><span class="slider-val"
                                        id="val-body-y">0¬∞</span></div>
                                <input type="range" id="body-y" min="-150" max="150" value="0">
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Emotions</h4>
                            <div class="emotion-actions">
                                <button onclick="triggerEmotion('happy')" class="action-btn" title="Happy">üòÑ</button>
                                <button onclick="triggerEmotion('excited')" class="action-btn" title="Excited">ü§©</button>
                                <button onclick="triggerEmotion('sad')" class="action-btn" title="Sad">üò¢</button>
                                <button onclick="triggerEmotion('angry')" class="action-btn" title="Angry">üò†</button>
                                <button onclick="triggerEmotion('confused')" class="action-btn" title="Confused">üòï</button>
                                <button onclick="triggerEmotion('surprised')" class="action-btn" title="Surprised">üò≤</button>
                                <button onclick="triggerEmotion('love')" class="action-btn" title="Love">üòç</button>
                                <button onclick="triggerEmotion('thinking')" class="action-btn" title="Thinking">ü§î</button>
                                <button onclick="triggerEmotion('cool')" class="action-btn" title="Cool">üòé</button>
                                <button onclick="triggerEmotion('yay')" class="action-btn" title="Yay">üéâ</button>
                                <button onclick="triggerEmotion('nervous')" class="action-btn" title="Nervous">üò∞</button>
                                <button onclick="triggerEmotion('sick')" class="action-btn" title="Sick">ü§í</button>
                                <button onclick="triggerEmotion('sleeping')" class="action-btn" title="Sleeping">üò¥</button>
                                <button onclick="triggerEmotion('party')" class="action-btn" title="Party">ü•≥</button>
                                <button onclick="triggerEmotion('clap')" class="action-btn" title="Applause">üëè</button>
                                <button onclick="triggerEmotion('thumbsup')" class="action-btn" title="Thumbs Up">üëç</button>
                                <button onclick="triggerEmotion('thumbsdown')" class="action-btn" title="Thumbs Down">üëé</button>
                                <button onclick="triggerEmotion('wave')" class="action-btn" title="Wave">üëã</button>
                                <button onclick="triggerEmotion('dance')" class="action-btn" title="Dance">üíÉ</button>
                                <button onclick="triggerEmotion('celebration')" class="action-btn" title="Celebration">üéä</button>
                                <button onclick="triggerEmotion('curious')" class="action-btn" title="Curious">ü§®</button>
                                <button onclick="triggerEmotion('grimace')" class="action-btn" title="Grimace">üò¨</button>
                                <button onclick="triggerEmotion('scared')" class="action-btn" title="Scared">üò®</button>
                                <button onclick="triggerEmotion('tired')" class="action-btn" title="Tired">üò´</button>
                                <button onclick="triggerEmotion('peaceful')" class="action-btn" title="Peaceful">üòå</button>
                            </div>
                        </div>
                        </div>
                    </div>

                    <!-- Voice controls should stay usable even when manual control is off -->
                    <div class="voice-controls">
                        <div class="control-group">
                            <h4>Voice Volume</h4>
                            <div class="slider-row">
                                <div class="slider-label"><span>Level</span><span class="slider-val" id="volume-val">50%</span></div>
                                <input type="range" id="volume-slider" min="0" max="100" value="50">
                            </div>
                        </div>
                        <div class="control-group" style="margin-top:12px;">
                            <h4 style="display:flex; align-items:center; justify-content:space-between;">
                                Microphone Level
                                <small id="mic-level-db-main" style="color:var(--text-muted); font-size:11px; font-weight:normal;">-‚àû dB</small>
                            </h4>
                            <div style="position:relative; height:12px; background:var(--bg-elevated); border-radius:6px; overflow:hidden;">
                                <div id="mic-level-bar-main" style="position:absolute; left:0; top:0; height:100%; width:0%; background:linear-gradient(90deg, #4ade80, #f97316, #ef4444); transition:width 0.1s ease-out;"></div>
                            </div>
                            <button id="test-mic-level-btn" style="margin-top:6px; padding:6px 12px; font-size:11px; background:var(--accent); color:#000; border:none; border-radius:3px; cursor:pointer;">Test Mic Level</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         RIGHT SIDEBAR - Chat + Data
         ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <div class="sidebar-right">
            <!-- Chat -->
            <div class="panel chat-panel">
                <div class="panel-title">Chat with Reachy</div>
                <div class="chat-messages" id="chat-messages">
                    <div class="msg msg-assistant">Hello! How can I help?</div>
                </div>
                <div class="chat-input">
                    <input type="text" id="chat-input" placeholder="Type a message...">
                    <button id="chat-send">Send</button>
                </div>
            </div>

            <!-- Tracking Data -->
            <div class="panel data-panel">
                <div class="panel-title">Live Tracking</div>
                <div class="panel-content" style="padding:0;">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Class</th>
                                <th>Score</th>
                            </tr>
                        </thead>
                        <tbody id="candidates-body"></tbody>
                    </table>
                    <div id="no-targets"
                        style="padding:16px; text-align:center; color:var(--text-muted); font-size:12px;">
                        No targets detected
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     SETTINGS MODAL
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚öôÔ∏è Settings</h2>
                <button class="modal-close" id="modal-close">‚úï</button>
            </div>
            <div class="modal-tabs">
                <button class="tab-btn active" data-tab="llm-tab">LLM Models</button>
                <button class="tab-btn" data-tab="voice-tab">Voice Settings</button>
                <button class="tab-btn" data-tab="tuning-tab">Tuning</button>
                <button class="tab-btn" data-tab="system-tab">System</button>
            </div>
            
            <!-- LLM Settings Tab -->
            <div id="llm-tab" class="tab-content active">
                <div class="settings-group">
                    <h3>Language Model Provider</h3>
                    <div class="provider-selector">
                        <button class="provider-btn active" data-provider="local">üì¶ Local</button>
                        <button class="provider-btn" data-provider="ollama">ü¶ô OLLAMA</button>
                        <button class="provider-btn" data-provider="openai">üöÄ OpenAI</button>
                    </div>
                </div>

                <!-- Local Models -->
                <div id="local-config" class="provider-config active">
                    <h4>Local Model Selection</h4>
                    <div class="settings-row">
                        <label>Current Model:</label>
                        <select id="local-model-select">
                            <option>Loading...</option>
                        </select>
                    </div>
                    <p class="info-text">üìå Local models run on your device without internet.</p>
                </div>

                <!-- OLLAMA Config -->
                <div id="ollama-config" class="provider-config">
                    <h4>OLLAMA Configuration</h4>
                    <div class="settings-row">
                        <label>OLLAMA Endpoint:</label>
                        <input type="text" id="ollama-endpoint" placeholder="http://localhost:11434" value="http://localhost:11434">
                    </div>
                    <div class="settings-row">
                        <label>Model:</label>
                        <select id="ollama-model-select">
                            <option>Not Connected</option>
                        </select>
                    </div>
                    <button id="ollama-test-btn" class="action-btn">Test Connection</button>
                    <p class="info-text">üìå OLLAMA allows you to run models locally with a server. <a href="https://ollama.ai" target="_blank">Get OLLAMA</a></p>
                </div>

                <!-- OpenAI Config -->
                <div id="openai-config" class="provider-config">
                    <h4>OpenAI API Configuration</h4>
                    <div class="settings-row">
                        <label>API Key:</label>
                        <input type="password" id="openai-key" placeholder="sk-...">
                    </div>
                    <div class="settings-row">
                        <label>Model:</label>
                        <select id="openai-model-select">
                            <option>Loading models...</option>
                        </select>
                    </div>
                    <button id="openai-test-btn" class="action-btn">Verify Key</button>
                    <p class="info-text">
                        üìå Get your API key at <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI API Keys</a>
                        <br>üí∞ View pricing at <a href="https://platform.openai.com/pricing" target="_blank">OpenAI Pricing</a>
                    </p>
                    
                    <!-- Pricing Table -->
                    <div id="pricing-container" style="display:none;">
                        <h5>Model Pricing (per 1M tokens)</h5>
                        <table class="pricing-table">
                            <thead>
                                <tr>
                                    <th>Model</th>
                                    <th>Category</th>
                                    <th>Input</th>
                                    <th>Output</th>
                                </tr>
                            </thead>
                            <tbody id="pricing-body">
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="settings-row" style="margin-top:20px;">
                    <button id="save-llm-btn" class="action-btn" style="background:var(--success); color:#000;">üíæ Save Settings</button>
                </div>
            </div>

            <!-- Voice Settings Tab -->
            <div id="voice-tab" class="tab-content">
                <div class="settings-group">
                    <h3>Text-to-Speech Settings</h3>
                    <div class="settings-row">
                        <label>Default Volume:</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="default-volume" min="0" max="100" value="50" style="flex:1;">
                            <span id="volume-display">50%</span>
                        </div>
                    </div>
                    <div class="settings-row" style="margin-top:10px;">
                        <label style="display:flex; align-items:center; gap:8px;">
                            <span>Microphone Level</span>
                            <small id="mic-level-db" style="color:var(--text-muted);">-‚àû dB</small>
                        </label>
                        <div style="position:relative; height:10px; background:var(--bg-elevated); border-radius:5px; overflow:hidden;">
                            <div id="mic-level-bar" style="position:absolute; left:0; top:0; height:100%; width:0%; background:linear-gradient(90deg, #4ade80, #f97316, #ef4444);"></div>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Live mic input from Reachy Mini. Moves when sound is detected.</p>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>Wake Word Detection</h3>
                    <p class="info-text">üé§ Hands-free activation - say the wake word to interact without pressing buttons.</p>
                    
                    <div class="settings-row">
                        <label>
                            <input type="checkbox" id="wake-word-enabled" style="margin-right:8px;">
                            Enable Wake Word Detection
                        </label>
                    </div>
                    
                    <div class="settings-row">
                        <label>Wake Word:</label>
                        <select id="wake-word-model" style="width:100%; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--bg-elevated); color:var(--text);">
                            <option value="hey_jarvis">Hey Jarvis</option>
                            <option value="alexa">Alexa</option>
                            <option value="hey_mycroft">Hey Mycroft</option>
                            <option value="hey_rhasspy">Hey Rhasspy</option>
                        </select>
                    </div>
                    
                    <div class="settings-row">
                        <label>Sensitivity (Detection Threshold):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="wake-word-threshold" min="0.1" max="0.9" step="0.05" value="0.5" style="flex:1;">
                            <span id="wake-word-threshold-val" style="min-width:60px;">0.50</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Lower = more sensitive (may have false triggers), Higher = less sensitive (may miss wake word).</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Listening Timeout (seconds):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="wake-word-timeout" min="3" max="15" step="1" value="5" style="flex:1;">
                            <span id="wake-word-timeout-val" style="min-width:60px;">5s</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">How long to listen for commands after wake word detected.</p>
                    </div>
                    
                    <div class="settings-row" style="margin-top:15px;">
                        <button id="save-wake-word-btn" class="action-btn" style="background:var(--success); color:#000;">üíæ Save Wake Word Settings</button>
                    </div>
                    
                    <div id="wake-word-status" style="margin-top:10px; padding:8px; border-radius:4px; background:var(--bg-elevated); font-size:12px; display:none;">
                        <strong>Status:</strong> <span id="wake-word-status-text">Initializing...</span>
                    </div>
                </div>
            </div>

            <!-- Tuning Settings Tab -->
            <div id="tuning-tab" class="tab-content">
                <div class="settings-group">
                    <h3>Detection & Tracking Tuning</h3>
                    <p class="info-text">‚öôÔ∏è Fine-tune robot behavior and tracking performance.</p>
                    
                    <div class="settings-row">
                        <label>Detection Interval (seconds):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-detection-interval" min="0.01" max="1.0" step="0.01" value="0.20" style="flex:1;">
                            <span id="tune-detection-interval-val" style="min-width:60px;">0.20s</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">How often to run object detection (0.01-1.0s). Lower = faster detection, higher CPU.</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Command Interval (seconds):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-command-interval" min="0.1" max="5.0" step="0.1" value="1.2" style="flex:1;">
                            <span id="tune-command-interval-val" style="min-width:60px;">1.2s</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">How often to send movement commands (0.1-5.0s). Lower = smoother tracking, more movement.</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Stream FPS Cap:</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-stream-fps-cap" min="1" max="60" step="1" value="60" style="flex:1;">
                            <span id="tune-stream-fps-cap-val" style="min-width:60px;">60 FPS</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Maximum video stream frame rate (1-60 FPS). Lower = reduced bandwidth.</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Min Score Threshold:</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-min-score-threshold" min="0" max="500" step="10" value="250" style="flex:1;">
                            <span id="tune-min-score-threshold-val" style="min-width:60px;">250</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Minimum score required to track a target (0-500). Higher = more selective.</p>
                    </div>
                    
                    <div class="settings-row">
                        <label>Recenter Timeout (seconds):</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="range" id="tune-recenter-timeout" min="0.5" max="10.0" step="0.5" value="2.0" style="flex:1;">
                            <span id="tune-recenter-timeout-val" style="min-width:60px;">2.0s</span>
                        </div>
                        <p class="info-text" style="font-size:11px; margin-top:4px;">Time before recentering after losing target (0.5-10.0s).</p>
                    </div>
                    
                    <div class="settings-row" style="margin-top:20px;">
                        <button id="save-tuning-btn" class="action-btn" style="background:var(--success); color:#000;">üíæ Save Tuning</button>
                        <button id="reset-tuning-btn" class="action-btn" style="background:var(--warning); color:#000; margin-left:10px;">üîÑ Reset to Defaults</button>
                    </div>
                </div>
            </div>

            <!-- System Settings Tab -->
            <div id="system-tab" class="tab-content">
                <div class="settings-group">
                    <h3>Debug & Logging</h3>
                    <div class="settings-row">
                        <label>
                            <input type="checkbox" id="verbose-logging" style="margin-right:8px;">
                            Enable Verbose Logging
                        </label>
                        <p class="info-text">üìå When enabled, all API requests (including polling) are logged to the console.</p>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>Debug & Logging</h3>
                    <div class="settings-row">
                        <label>
                            <input type="checkbox" id="verbose-logging-toggle" style="margin-right:8px;">
                            Browser Console Logging
                        </label>
                        <p class="info-text">üîß Enable detailed logging for troubleshooting and development.</p>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h3>About</h3>
                    <p>Reachy Control v1.0</p>
                    <p id="backend-info" style="font-size:12px; color:var(--text-muted);">Backend: Initializing...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        let isPaused = true, voiceEnabled = false, wiggleEnabled = false;  // Start paused to match server default
        let verboseLogging = localStorage.getItem('verbose_logging') === 'true';

        // Simple console logger wrapper
        const logger = {
            info: (...args) => verboseLogging && console.log('[INFO]', ...args),
            warn: (...args) => verboseLogging && console.warn('[WARN]', ...args),
            error: (...args) => verboseLogging && console.error('[ERROR]', ...args)
        };
        
        const vlog = (...args) => verboseLogging && console.log(...args);
        
        // Set up verbose logging toggle
        window.addEventListener('load', () => {
            const toggle = $('verbose-logging-toggle');
            if (toggle) {
                toggle.checked = verboseLogging;
                toggle.addEventListener('change', (e) => {
                    verboseLogging = e.target.checked;
                    localStorage.setItem('verbose_logging', verboseLogging ? 'true' : 'false');
                    vlog('[SETTINGS] Verbose logging toggled to:', verboseLogging);
                });
            }
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHAT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function addMsg(role, text) {
            const el = document.createElement('div');
            el.className = `msg msg-${role}`;
            el.textContent = text;
            $('chat-messages').appendChild(el);
            $('chat-messages').scrollTop = $('chat-messages').scrollHeight;
        }

        $('chat-send').onclick = async () => {
            const input = $('chat-input');
            const text = input.value.trim();
            if (!text) return;
            addMsg('user', text);
            input.value = '';
            try {
                const res = await fetch('/api/voice/text_command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text, speak: true })
                });
                const data = await res.json();
                if (data.response) addMsg('assistant', data.response);
            } catch (e) {
                addMsg('system', 'Error sending message');
            }
        };

        $('chat-input').onkeypress = e => { if (e.key === 'Enter') $('chat-send').click(); };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ACTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        $('reset-btn').onclick = () => fetch('/api/reset', { method: 'POST' });

        $('pause-btn').onclick = async () => {
            const res = await fetch('/api/toggle_pause', { method: 'POST' });
            const data = await res.json();
            isPaused = data.paused;
            updatePauseUI();
        };

        function updatePauseUI() {
            const btn = $('pause-btn');
            const overlay = $('manual-overlay');
            vlog('[updatePauseUI] isPaused:', isPaused, 'btn exists:', !!btn, 'overlay exists:', !!overlay);
            
            if (!btn || !overlay) {
                vlog('[updatePauseUI] ERROR: DOM elements not found! btn:', btn, 'overlay:', overlay);
                return;
            }
            
            if (isPaused) {
                btn.classList.add('active');
                btn.innerHTML = '<span class="icon">‚ñ∂Ô∏è</span> Resume';
                overlay.style.opacity = '1';
                overlay.style.pointerEvents = 'auto';
                vlog('[updatePauseUI] Applied PAUSED state: active=true, opacity=1');
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<span class="icon">‚è∏Ô∏è</span> Pause Tracking';
                overlay.style.opacity = '0.4';
                overlay.style.pointerEvents = 'none';
                vlog('[updatePauseUI] Applied RUNNING state: active=false, opacity=0.4');
            }
        }

        $('wiggle-btn').onclick = async () => {
            await fetch('/api/toggle_wiggle', { method: 'POST' });
        };

        async function triggerEmotion(emotion) {
            try {
                await fetch('/api/emote', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ emotion })
                });
            } catch (e) { console.error(e); }
        }

        $('voice-btn').onclick = async () => {
            const ep = voiceEnabled ? '/api/voice/disable' : '/api/voice/enable';
            const res = await fetch(ep, { method: 'POST' });
            const data = await res.json();
            voiceEnabled = data.voice_enabled;
            $('voice-btn').classList.toggle('active', voiceEnabled);
        };

        $('restart-btn').onclick = async () => {
            if (confirm('Restart the system? This will reload all settings and reconnect to the robot.')) {
                await fetch('/api/restart', { method: 'POST' });
                document.body.innerHTML = '<div style="display:flex;height:100vh;align-items:center;justify-content:center;color:#fff;font-family:sans-serif;"><h1>üîÑ Restarting...</h1><p>Please wait, the page will reload automatically.</p></div>';
                // Wait a moment then reload
                setTimeout(() => {
                    window.location.reload();
                }, 3000);
            }
        };

        $('power-btn').onclick = async () => {
            if (confirm('Shutdown the system?')) {
                await fetch('/api/shutdown', { method: 'POST' });
                document.body.innerHTML = '<div style="display:flex;height:100vh;align-items:center;justify-content:center;color:#fff;font-family:sans-serif;"><h1>System Offline</h1></div>';
            }
        };

        window.setMotorMode = mode => {
            fetch('/api/motor_mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode })
            });
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SLIDERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const sliders = ['ant-l', 'ant-r', 'head-y', 'head-p', 'head-r', 'body-y'];
        const active = new Set();

        sliders.forEach(id => {
            const el = $(id), val = $('val-' + id);
            el.oninput = () => val.textContent = el.value + '¬∞';
            el.onmousedown = () => active.add(id);
            el.onmouseup = () => { active.delete(id); sendManual(); };
            el.ontouchstart = () => active.add(id);
            el.ontouchend = () => { active.delete(id); sendManual(); };
        });

        function sendManual() {
            if (!isPaused) return;
            fetch('/api/manual_control', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    antenna_left: +$('ant-l').value,
                    antenna_right: +$('ant-r').value,
                    head_yaw: +$('head-y').value,
                    head_pitch: +$('head-p').value,
                    head_roll: +$('head-r').value,
                    body_yaw: +$('body-y').value
                })
            });
        }

        // Volume (Main screen)
        $('volume-slider').oninput = e => $('volume-val').textContent = e.target.value + '%';
        $('volume-slider').onchange = e => {
            fetch('/api/voice/volume', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ volume: +e.target.value })
            });
        };

        // Volume (Settings menu)
        $('default-volume').oninput = e => {
            $('volume-display').textContent = e.target.value + '%';
            // Sync with main volume slider
            $('volume-slider').value = e.target.value;
            $('volume-val').textContent = e.target.value + '%';
        };
        $('default-volume').onchange = e => {
            fetch('/api/voice/volume', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ volume: +e.target.value })
            });
        };

        // Mic level polling for soundbar indicator
        function startMicLevelPolling() {
            // Use main visible bar if available, fallback to settings bar
            let bar = $('mic-level-bar-main');
            let dbLabel = $('mic-level-db-main');
            
            // Also try to update the settings version if it's loaded
            let settingsBar = $('mic-level-bar');
            let settingsDbLabel = $('mic-level-db');

            if (!bar && !settingsBar) return;

            let lastValue = 0;
            const smoothing = 0.35; // simple low-pass smoothing
            const intervalMs = 200; // 5 Hz polling

            async function poll() {
                try {
                    const resp = await fetch('/api/voice/level');
                    if (!resp.ok) throw new Error('level request failed');
                    const data = await resp.json();

                    const rms = typeof data.rms === 'number' ? data.rms : 0;
                    const db = typeof data.db === 'number' ? data.db : -Infinity;

                    const maxRms = 0.2; // clamp to typical speech RMS
                    const target = Math.max(0, Math.min(1, rms / maxRms));
                    lastValue = lastValue + smoothing * (target - lastValue);
                    const pct = Math.round(lastValue * 100);
                    
                    const dbText = Number.isFinite(db) ? `${db.toFixed(1)} dB` : '-‚àû dB';

                    // Update main bar
                    if (bar) bar.style.width = `${pct}%`;
                    if (dbLabel) dbLabel.textContent = dbText;

                    // Update settings bar (if visible)
                    if (settingsBar) settingsBar.style.width = `${pct}%`;
                    if (settingsDbLabel) settingsDbLabel.textContent = dbText;
                } catch (err) {
                    // silently ignore to keep UI calm
                }
            }

            poll();
            setInterval(poll, intervalMs);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // THEME SELECTION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function initTheme() {
            const saved = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', saved);
            $('theme-select').value = saved;
        }
        
        $('theme-select').onchange = e => {
            const theme = e.target.value;
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        };
        
        initTheme();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SETTINGS MODAL
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        $('settings-btn').onclick = () => $('settings-modal').classList.add('active');
        $('modal-close').onclick = () => $('settings-modal').classList.remove('active');
        
        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                btn.classList.add('active');
                $(btn.dataset.tab).classList.add('active');
            };
        });
        
        // Provider switching
        document.querySelectorAll('.provider-btn').forEach(btn => {
            btn.onclick = async () => {
                document.querySelectorAll('.provider-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.provider-config').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                const provider = btn.dataset.provider;
                $(provider + '-config').classList.add('active');
                
                // Load provider-specific data
                if (provider === 'openai') {
                    // Check if OpenAI config is already saved
                    try {
                        const res = await fetch('/api/llm/status');
                        const data = await res.json();
                        
                        if (data.provider === 'openai' && data.config.has_api_key) {
                            // Key is saved - show placeholder and load models with stored key
                            $('openai-key').placeholder = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                            $('openai-key').value = '';
                            $('openai-key').style.opacity = '0.6';
                            
                            await loadOpenAIModels(true);
                            
                            // Pre-select the saved model
                            if (data.config.model) {
                                $('openai-model-select').value = data.config.model;
                            }
                        } else {
                            // No saved key - reset form
                            $('openai-key').placeholder = 'sk-...';
                            $('openai-key').value = '';
                            $('openai-key').style.opacity = '1';
                            loadOpenAIModels();
                        }
                    } catch (e) {
                        console.error('Error loading OpenAI config:', e);
                        loadOpenAIModels();
                    }
                } else if (provider === 'ollama') {
                    loadOLLAMAModels();
                } else if (provider === 'local') {
                    loadLocalModels();
                }
            };
        });
        
        // Load local models
        async function loadLocalModels() {
            try {
                const res = await fetch('/api/llm/models/local');
                const data = await res.json();
                const select = $('local-model-select');
                select.innerHTML = '';
                (data.models || []).forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    opt.textContent = m.name;
                    if (m.current) opt.selected = true;
                    select.appendChild(opt);
                });
            } catch (e) {
                console.error('Error loading local models:', e);
            }
        }
        
        // Load OLLAMA models
        async function loadOLLAMAModels() {
            try {
                const endpoint = $('ollama-endpoint').value;
                const res = await fetch('/api/llm/models/ollama?endpoint=' + encodeURIComponent(endpoint));
                const data = await res.json();
                const select = $('ollama-model-select');
                select.innerHTML = '';
                if (data.models && data.models.length > 0) {
                    data.models.forEach(m => {
                        const opt = document.createElement('option');
                        opt.value = m;
                        opt.textContent = m;
                        select.appendChild(opt);
                    });
                } else {
                    select.innerHTML = '<option>Not Connected</option>';
                }
            } catch (e) {
                console.error('Error loading OLLAMA models:', e);
                $('ollama-model-select').innerHTML = '<option>Connection Failed</option>';
            }
        }
        
        // Load OpenAI models
        async function loadOpenAIModels(useStoredKey = false) {
            try {
                let apiKey = $('openai-key').value;
                
                // If no key entered but one is stored, load models using backend's stored key
                if (!apiKey && useStoredKey) {
                    // Fetch models using the backend's stored key
                    const res = await fetch('/api/llm/models/openai', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ api_key: null })  // null tells backend to use stored key
                    });
                    const data = await res.json();
                    const select = $('openai-model-select');
                    select.innerHTML = '';
                    if (data.models && data.models.length > 0) {
                        data.models.forEach(m => {
                            const opt = document.createElement('option');
                            opt.value = m.id;
                            opt.textContent = m.name;
                            select.appendChild(opt);
                        });
                        
                        // Show pricing
                        if (data.pricing && data.pricing.length > 0) {
                            const tbody = $('pricing-body');
                            tbody.innerHTML = '';
                            data.pricing.forEach(p => {
                                const tr = document.createElement('tr');
                                tr.innerHTML = `<td><strong>${p.model}</strong></td><td style="font-size:11px;color:var(--accent);">${p.category}</td><td>${p.input_price}</td><td>${p.output_price}</td>`;
                                tbody.appendChild(tr);
                            });
                            $('pricing-container').style.display = 'block';
                        }
                    }
                    return;
                }
                
                if (!apiKey) {
                    $('openai-model-select').innerHTML = '<option>Enter API key first</option>';
                    return;
                }
                const res = await fetch('/api/llm/models/openai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ api_key: apiKey })
                });
                const data = await res.json();
                const select = $('openai-model-select');
                select.innerHTML = '';
                if (data.models && data.models.length > 0) {
                    data.models.forEach(m => {
                        const opt = document.createElement('option');
                        opt.value = m.id;
                        opt.textContent = m.name;
                        select.appendChild(opt);
                    });
                    
                    // Show pricing
                    if (data.pricing && data.pricing.length > 0) {
                        const tbody = $('pricing-body');
                        tbody.innerHTML = '';
                        data.pricing.forEach(p => {
                            const tr = document.createElement('tr');
                            tr.innerHTML = `<td><strong>${p.model}</strong></td><td style="font-size:11px;color:var(--accent);">${p.category}</td><td>${p.input_price}</td><td>${p.output_price}</td>`;
                            tbody.appendChild(tr);
                        });
                        $('pricing-container').style.display = 'block';
                    }
                } else {
                    select.innerHTML = '<option>Error: Invalid API key</option>';
                }
            } catch (e) {
                console.error('Error loading OpenAI models:', e);
                $('openai-model-select').innerHTML = '<option>Error loading models</option>';
            }
        }
        
        // Test buttons
        $('ollama-test-btn').onclick = () => {
            loadOLLAMAModels();
        };
        
        $('openai-test-btn').onclick = async () => {
            const apiKey = $('openai-key').value;
            if (!apiKey) {
                alert('Please enter your API key');
                return;
            }
            try {
                const res = await fetch('/api/llm/validate-key', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ api_key: apiKey, provider: 'openai' })
                });
                const data = await res.json();
                if (data.valid) {
                    alert('‚úÖ API key is valid!');
                    loadOpenAIModels();
                } else {
                    alert('‚ùå API key is invalid: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error verifying key: ' + e.message);
            }
        };
        
        // Save settings
        $('save-llm-btn').onclick = async () => {
            const provider = document.querySelector('.provider-btn.active').dataset.provider;
            const config = {};
            
            if (provider === 'local') {
                config.model_id = $('local-model-select').value;
            } else if (provider === 'ollama') {
                config.endpoint = $('ollama-endpoint').value;
                config.model = $('ollama-model-select').value;
            } else if (provider === 'openai') {
                config.api_key = $('openai-key').value;
                config.model = $('openai-model-select').value;
            }
            
            try {
                const res = await fetch('/api/llm/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ provider, config })
                });
                const data = await res.json();
                if (data.success) {
                    alert('‚úÖ Settings saved successfully!');
                    $('settings-modal').classList.remove('active');
                } else {
                    alert('‚ùå Error saving settings: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error: ' + e.message);
            }
        };
        
        // Load initial data
        loadLocalModels();
        
        // Load saved LLM configuration on page load
        async function loadSavedLLMConfig() {
            try {
                const res = await fetch('/api/llm/status');
                const data = await res.json();
                
                if (data.provider) {
                    // Set the active provider button
                    document.querySelectorAll('.provider-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.provider === data.provider) {
                            btn.classList.add('active');
                        }
                    });
                    
                    // Show the correct provider config
                    document.querySelectorAll('.provider-config').forEach(cfg => cfg.classList.remove('active'));
                    $(data.provider + '-config').classList.add('active');
                    
                    // Populate saved settings
                    if (data.provider === 'local' && data.config.model_id) {
                        $('local-model-select').value = data.config.model_id;
                    } else if (data.provider === 'ollama') {
                        if (data.config.endpoint) $('ollama-endpoint').value = data.config.endpoint;
                        if (data.config.model) $('ollama-model-select').value = data.config.model;
                    } else if (data.provider === 'openai') {
                        // Show placeholder if API key is already saved
                        if (data.config.has_api_key) {
                            $('openai-key').placeholder = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                            $('openai-key').value = '';
                            $('openai-key').style.opacity = '0.6';
                            
                            // Load OpenAI models using stored key
                            await loadOpenAIModels(true);
                            
                            // Set the selected model
                            if (data.config.model) {
                                $('openai-model-select').value = data.config.model;
                            }
                        }
                    }
                    
                    logger.info(`Loaded LLM config: provider=${data.provider}`);
                }
            } catch (e) {
                console.error('Error loading LLM config:', e);
            }
        }
        
        loadSavedLLMConfig();
        
        // Verbose logging toggle
        function initVerboseLogging() {
            const saved = localStorage.getItem('verbose-logging') === 'true';
            $('verbose-logging').checked = saved;
            sendVerboseSetting(saved);
        }
        
        $('verbose-logging').onchange = e => {
            const enabled = e.target.checked;
            localStorage.setItem('verbose-logging', enabled);
            sendVerboseSetting(enabled);
        };
        
        async function sendVerboseSetting(enabled) {
            try {
                await fetch('/api/settings/verbose', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ verbose: enabled })
                });
            } catch (e) {
                console.error('Error setting verbose logging:', e);
            }
        }
        
        initVerboseLogging();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TUNING SETTINGS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const tuningParams = [
            { id: 'detection-interval', key: 'detection_interval', suffix: 's', decimals: 2 },
            { id: 'command-interval', key: 'command_interval', suffix: 's', decimals: 1 },
            { id: 'stream-fps-cap', key: 'stream_fps_cap', suffix: ' FPS', decimals: 0 },
            { id: 'min-score-threshold', key: 'min_score_threshold', suffix: '', decimals: 0 },
            { id: 'recenter-timeout', key: 'recenter_timeout', suffix: 's', decimals: 1 }
        ];
        
        // Initialize tuning controls
        tuningParams.forEach(param => {
            const slider = $('tune-' + param.id);
            const display = $('tune-' + param.id + '-val');
            
            slider.oninput = () => {
                const val = parseFloat(slider.value);
                display.textContent = val.toFixed(param.decimals) + param.suffix;
            };
        });
        
        // Load current tuning values
        async function loadTuningSettings() {
            try {
                // Try to load from localStorage first (for persistence across page reloads)
                const savedTuning = localStorage.getItem('tuning-settings');
                let data = null;
                
                if (savedTuning) {
                    try {
                        data = JSON.parse(savedTuning);
                        logger.info('Loaded tuning from localStorage');
                    } catch (e) {
                        logger.warn('Invalid localStorage tuning data, fetching from server');
                    }
                }
                
                // Fetch from server (authoritative source)
                const res = await fetch('/api/tuning');
                if (res.ok) {
                    data = await res.json();
                    // Update localStorage with server values
                    localStorage.setItem('tuning-settings', JSON.stringify(data));
                }
                
                if (data) {
                    tuningParams.forEach(param => {
                        const slider = $('tune-' + param.id);
                        const display = $('tune-' + param.id + '-val');
                        const value = data[param.key];
                        
                        if (value !== undefined) {
                            slider.value = value;
                            display.textContent = parseFloat(value).toFixed(param.decimals) + param.suffix;
                        }
                    });
                    
                    logger.info('Loaded tuning settings');
                }
            } catch (e) {
                console.error('Error loading tuning settings:', e);
            }
        }
        
        // Save tuning settings
        $('save-tuning-btn').onclick = async () => {
            const tuning = {};
            tuningParams.forEach(param => {
                const slider = $('tune-' + param.id);
                tuning[param.key] = parseFloat(slider.value);
            });
            
            try {
                const res = await fetch('/api/tuning', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(tuning)
                });
                
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                
                const data = await res.json();
                
                // Save to localStorage for persistence
                localStorage.setItem('tuning-settings', JSON.stringify(tuning));
                
                if (data.warnings && data.warnings.length > 0) {
                    alert('‚ö†Ô∏è Tuning saved with warnings:\n' + data.warnings.join('\n'));
                } else {
                    alert('‚úÖ Tuning settings saved successfully!');
                }
                
                logger.info('Saved tuning settings:', tuning);
            } catch (e) {
                console.error('Error saving tuning:', e);
                alert('‚ùå Error saving tuning settings: ' + e.message);
            }
        };
        
        // Reset to defaults
        $('reset-tuning-btn').onclick = async () => {
            if (!confirm('Reset all tuning parameters to defaults?')) return;
            
            const defaults = {
                detection_interval: 0.20,
                command_interval: 1.2,
                stream_fps_cap: 60.0,
                min_score_threshold: 250.0,
                recenter_timeout: 2.0
            };
            
            try {
                const res = await fetch('/api/tuning', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(defaults)
                });
                
                await loadTuningSettings(); // Reload values
                alert('‚úÖ Tuning reset to defaults!');
                logger.info('Reset tuning to defaults');
            } catch (e) {
                console.error('Error resetting tuning:', e);
                alert('‚ùå Error resetting tuning settings');
            }
        };
        
        // Load tuning on page load
        loadTuningSettings();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WAKE WORD DETECTION SETTINGS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        async function loadWakeWordSettings() {
            try {
                const res = await fetch('/api/voice/wake-word/status');
                const data = await res.json();
                
                $('wake-word-enabled').checked = data.enabled || false;
                $('wake-word-model').value = data.wake_word || 'hey_jarvis';
                $('wake-word-threshold').value = data.threshold || 0.5;
                $('wake-word-threshold-val').textContent = (data.threshold || 0.5).toFixed(2);
                $('wake-word-timeout').value = data.timeout || 5;
                $('wake-word-timeout-val').textContent = (data.timeout || 5) + 's';
                
                // Show status
                $('wake-word-status').style.display = 'block';
                const modelStatus = data.model_loaded ? '‚úÖ Loaded' : '‚è≥ Not loaded';
                $('wake-word-status-text').textContent = `${data.enabled ? 'Enabled' : 'Disabled'} | Model: ${modelStatus}`;
                
                logger.info('Wake word settings loaded:', data);
            } catch (e) {
                console.error('Error loading wake word settings:', e);
            }
        }
        
        // Update threshold display in real-time
        $('wake-word-threshold').oninput = () => {
            $('wake-word-threshold-val').textContent = parseFloat($('wake-word-threshold').value).toFixed(2);
        };
        
        // Update timeout display in real-time
        $('wake-word-timeout').oninput = () => {
            $('wake-word-timeout-val').textContent = $('wake-word-timeout').value + 's';
        };
        
        // Save wake word settings
        $('save-wake-word-btn').onclick = async () => {
            try {
                const settings = {
                    enabled: $('wake-word-enabled').checked,
                    wake_word: $('wake-word-model').value,
                    threshold: parseFloat($('wake-word-threshold').value),
                    timeout: parseFloat($('wake-word-timeout').value)
                };
                
                const res = await fetch('/api/voice/wake-word/configure', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(settings)
                });
                
                const data = await res.json();
                if (data.status === 'ok') {
                    await loadWakeWordSettings(); // Reload to confirm
                    alert('‚úÖ Wake word settings saved! Changes will apply when voice assistant is next enabled.');
                    logger.info('Wake word settings saved:', settings);
                } else {
                    alert('‚ùå Error: ' + (data.message || 'Unknown error'));
                }
            } catch (e) {
                console.error('Error saving wake word settings:', e);
                alert('‚ùå Error saving wake word settings');
            }
        };
        
        // Load wake word settings when voice tab is opened
        document.querySelector('[data-tab="voice-tab"]').addEventListener('click', loadWakeWordSettings);
        
        // Initial load when page loads (if voice tab is already open)
        loadWakeWordSettings();
        startMicLevelPolling();

         // Test mic level API
         $('test-mic-level-btn').onclick = async () => {
             try {
                 const resp = await fetch('/api/voice/level');
                 const data = await resp.json();
                 console.log('Mic level API response:', data);
                 alert(`API Response:\nRMS: ${data.rms?.toFixed(4) || 'N/A'}\ndB: ${data.db?.toFixed(1) || 'N/A'}`);
                 
                 // Test bar rendering: set to 50%
                 const bar = $('mic-level-bar-main');
                 if (bar) {
                     bar.style.width = '50%';
                     console.log('Bar set to 50% for testing');
                 } else {
                     console.warn('Bar element not found');
                 }
             } catch (err) {
                 alert('Error fetching mic level: ' + err.message);
                 console.error(err);
             }
         };
        let nyanAnimationId = null;
        let nyanCanvas = null;
        let nyanCtx = null;
        
        function initNyanCat() {
            const theme = document.documentElement.getAttribute('data-theme');
            if (theme !== 'nyan') {
                cleanupNyanCat();
                return;
            }
            
            // Create canvas
            if (!nyanCanvas) {
                nyanCanvas = document.createElement('canvas');
                nyanCanvas.id = 'nyan-canvas';
                nyanCanvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 9997;
                `;
                document.body.appendChild(nyanCanvas);
                nyanCtx = nyanCanvas.getContext('2d');
                
                // Set canvas size
                function resizeCanvas() {
                    nyanCanvas.width = window.innerWidth;
                    nyanCanvas.height = window.innerHeight;
                }
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }
            
            const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#8b00ff'];
            const trail = [];
            let time = 0;
            
            function drawNyanCat() {
                const theme = document.documentElement.getAttribute('data-theme');
                if (theme !== 'nyan') {
                    cleanupNyanCat();
                    return;
                }
                
                // Clear canvas
                nyanCtx.clearRect(0, 0, nyanCanvas.width, nyanCanvas.height);
                
                time += 16;
                const duration = 8000;
                const progress = (time % duration) / duration;
                
                // Cat position
                const catX = -50 + (nyanCanvas.width + 100) * progress;
                let yPercent;
                if (progress < 0.25) {
                    yPercent = 0.20 + (0.30 - 0.20) * (progress / 0.25);
                } else if (progress < 0.5) {
                    yPercent = 0.30 + (0.25 - 0.30) * ((progress - 0.25) / 0.25);
                } else if (progress < 0.75) {
                    yPercent = 0.25 + (0.35 - 0.25) * ((progress - 0.5) / 0.25);
                } else {
                    yPercent = 0.35 + (0.20 - 0.35) * ((progress - 0.75) / 0.25);
                }
                const catY = nyanCanvas.height * yPercent;
                
                // Add trail point
                trail.push({ x: catX, y: catY, time: Date.now() });
                
                // Remove old trail points
                const now = Date.now();
                while (trail.length > 0 && now - trail[0].time > 2000) {
                    trail.shift();
                }
                
                // Draw rainbow trail
                const stripeHeight = 8;
                const totalHeight = colors.length * stripeHeight;
                
                for (let i = 0; i < trail.length - 1; i++) {
                    const p1 = trail[i];
                    const p2 = trail[i + 1];
                    const age = (now - p1.time) / 2000;
                    const opacity = 1 - age;
                    
                    if (opacity > 0) {
                        colors.forEach((color, colorIdx) => {
                            nyanCtx.strokeStyle = color;
                            nyanCtx.lineWidth = stripeHeight;
                            nyanCtx.globalAlpha = opacity * 0.9;
                            nyanCtx.shadowBlur = 10;
                            nyanCtx.shadowColor = color;
                            
                            nyanCtx.beginPath();
                            nyanCtx.moveTo(p1.x, p1.y + colorIdx * stripeHeight - totalHeight/2);
                            nyanCtx.lineTo(p2.x, p2.y + colorIdx * stripeHeight - totalHeight/2);
                            nyanCtx.stroke();
                        });
                    }
                }
                
                // Reset shadow
                nyanCtx.shadowBlur = 0;
                nyanCtx.globalAlpha = 1;
                
                // Draw cat emoji
                nyanCtx.font = '48px Arial';
                nyanCtx.filter = 'drop-shadow(0 0 10px rgba(255, 102, 204, 0.8))';
                nyanCtx.fillText('üê±', catX, catY);
                nyanCtx.filter = 'none';
                
                nyanAnimationId = requestAnimationFrame(drawNyanCat);
            }
            
            drawNyanCat();
        }
        
        function cleanupNyanCat() {
            if (nyanAnimationId) {
                cancelAnimationFrame(nyanAnimationId);
                nyanAnimationId = null;
            }
            if (nyanCanvas && nyanCanvas.parentNode) {
                nyanCanvas.parentNode.removeChild(nyanCanvas);
                nyanCanvas = null;
                nyanCtx = null;
            }
        }
        
        // Initialize on theme change
        const themeSelect = document.getElementById('theme-select');
        const originalThemeChange = themeSelect.onchange;
        themeSelect.onchange = function(e) {
            if (originalThemeChange) originalThemeChange.call(this, e);
            setTimeout(initNyanCat, 100);
        };
        
        // Initialize if already on nyan theme
        initNyanCat();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // POLLING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        async function refreshStatus() {
            try {
                const res = await fetch('/status');
                const data = await res.json();

                // Status
                $('status-text').textContent = data.status || 'Ready';

                // Wiggle
                wiggleEnabled = data.wiggle_enabled;
                $('wiggle-btn').classList.toggle('active', wiggleEnabled);

                // Pause sync
                if (data.paused !== undefined) {
                    isPaused = data.paused;
                    updatePauseUI();
                }

                // Candidates
                const tbody = $('candidates-body');
                const noT = $('no-targets');
                if (data.candidates?.length) {
                    noT.style.display = 'none';
                    tbody.innerHTML = '';
                    data.candidates.sort((a, b) => b.score - a.score).slice(0, 5).forEach(c => {
                        const tr = document.createElement('tr');
                        if (c.id == data.current_target_id) tr.classList.add('active');
                        tr.innerHTML = `<td>#${c.id}</td><td>${c.label}</td><td>${Math.round(c.score)}</td>`;
                        tbody.appendChild(tr);
                    });
                } else {
                    tbody.innerHTML = '';
                    noT.style.display = 'block';
                }

                // Slider sync
                if (data.pose) {
                    const deg = r => (r * 180 / Math.PI);
                    const map = {
                        'ant-l': data.pose.antenna_left,
                        'ant-r': data.pose.antenna_right,
                        'head-y': deg(data.pose.head_yaw),
                        'head-p': deg(data.pose.head_pitch),
                        'head-r': deg(data.pose.head_roll),
                        'body-y': deg(data.pose.body_yaw)
                    };
                    for (const [id, v] of Object.entries(map)) {
                        if (!active.has(id)) {
                            $(id).value = v;
                            $('val-' + id).textContent = Math.round(v) + '¬∞';
                        }
                    }
                }

                // Voice polling
                if (voiceEnabled) {
                    const vr = await fetch('/api/voice/status');
                    const vd = await vr.json();
                    if (vd.conversation_history?.length) {
                        const last = vd.conversation_history[vd.conversation_history.length - 1];
                        if (last.role === 'assistant' && window.lastA !== last.content) {
                            window.lastA = last.content;
                            addMsg('assistant', last.content);
                        }
                    }
                }
            } catch (e) { }
        }
        
        // Initial status fetch on page load
        async function initializePageState() {
            vlog('[initializePageState] Starting async fetch...');
            try {
                const res = await fetch('/status');
                const data = await res.json();
                
                // Set initial pause state from server
                if (data.paused !== undefined) {
                    isPaused = data.paused;
                    vlog('[initializePageState] Fetched server state: paused =', isPaused);
                } else {
                    vlog('[initializePageState] Server did not return paused state');
                }
            } catch (e) {
                console.error('[initializePageState] Failed to fetch:', e);
            }
            // Always update UI after fetching (or on failure with default)
            vlog('[initializePageState] Calling updatePauseUI after server fetch');
            updatePauseUI();
        }
        
        // Wait for DOM to be fully loaded before running initialization
        function startInitialization() {
            vlog('[INIT] DOM Ready. isPaused =', isPaused);
            vlog('[INIT] DOM check - pause-btn:', !!document.getElementById('pause-btn'), 'manual-overlay:', !!document.getElementById('manual-overlay'));
            
            vlog('[INIT] Calling updatePauseUI immediately');
            updatePauseUI();
            
            vlog('[INIT] Calling initializePageState async');
            initializePageState();
            
            // Poll every 500ms
            setInterval(refreshStatus, 500);
        }
        
        // Run on page load
        if (document.readyState === 'loading') {
            vlog('[INIT] Document still loading, waiting for DOMContentLoaded...');
            document.addEventListener('DOMContentLoaded', startInitialization);
        } else {
            vlog('[INIT] Document already loaded, starting immediately...');
            startInitialization();
        }
    </script>
</body>

</html>